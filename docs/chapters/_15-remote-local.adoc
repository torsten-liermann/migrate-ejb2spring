== Remote and local interfaces
EJB provides local and remote interfaces (`@Local`, `@Remote`) as part of the component model. Remote calls are container managed and use standardized protocols. Spring Boot does not have a direct EJB equivalent. Migration therefore requires a conscious choice of a communication style (RPC-like via HTTP, REST API, gRPC or other frameworks).
=== Local interfaces
Local interfaces are used in the same module and can usually be replaced directly by class references in Spring. An explicit interface definition still makes sense if it expresses technical boundaries or makes testing easier.
=== Remote interfaces
There is no corresponding container remoting in Spring for `@Remote` beans. The target architecture must explicitly specify whether remote calls are mapped as HTTP-based RPC calls, REST APIs, messaging or gRPC. EJB-specific features such as pass-through security or declarative transactions across remote boundaries must be explicitly modeled in Spring.
=== Options for @Remote alternatives (as of 2026-01-23)
The following options are considered alternatives to EJB Remote. The metrics come from the respective GitHub repositories (license, releases, contributor statistics) and are documented with a time stamp.
[NOTE]====
Data status: 2026-01-23. “Releases (12M)” is based on GitHub releases from the last 12 months. “Active Committers (52W)” is based on GitHub `stats/contributors`. If GitHub does not provide the statistics, the value is marked as "n/a".====

[cols="2,3,1,1,1,1,2"]|===
| option | GitHub URL | License | Releases (12M) | Latest release | Active Committers (52W) | Proximity to HttpInvoker/IIOP

| Apache Dubbo (Triple)
| https://github.com/apache/dubbo
| Apache-2.0
| 6
| 2025-11-13
| n/v (GitHub Stats 202)
| HttpInvoker-close (RPC over HTTP), IIOP-far

| spring-boot-rest-http-invoker
| https://github.com/jc-lab/spring-boot-rest-http-invoker
| Apache-2.0
| 0
| – (no GitHub releases)
| n/v (GitHub Stats 202)
| HttpInvoker-close (RPC over HTTP), IIOP-far

| spring-rest-invoker
| https://github.com/ggeorgovassilis/spring-rest-invoker
| Apache-2.0
| 0
| 2017-11-19
| n/v (GitHub Stats 202)
| HttpInvoker-close (RPC over HTTP), IIOP-far

| Hessian (Fork: floating-clouds)
| https://github.com/floating-clouds/hessian-spring-boot
| Apache-2.0
| 0
| – (no GitHub releases)
| n/v (GitHub Stats 202)
| HttpInvoker-close (RPC over HTTP/Binary), IIOP-far

| Hessian (Fork: linux-china)
| https://github.com/linux-china/hessian-spring-boot-starter
| n/a (license not declared)
| 0
| – (no GitHub releases)
| n/v (GitHub Stats 202)
| HttpInvoker-close (RPC over HTTP/Binary), IIOP-far

| gRPC (Core)
| https://github.com/grpc/grpc
| Apache-2.0
| 26
| 2026-01-15
| 28
| RPC-close (HTTP/2, IDL required), HttpInvoker-far

| RSocket (Java)
| https://github.com/rsocket/rsocket-java
| Apache-2.0
| 1
| 2025-02-03
| n/v (GitHub Stats 202)
| RPC-close (no HTTP transport), HttpInvoker-far

| Apache CXF (Simple Frontend)
| https://github.com/apache/cxf
| Apache-2.0
| 0
| – (no GitHub releases)
| 13
| SOAP-based, RPC-near over HTTP, HttpInvoker-far
|===

=== Options in detail
==== Apache Dubbo (Triple)
Advantages:
- Java interface as a contract (RPC style)
- HTTP/2 transport, service discovery integration possible
Disadvantages:
- Additional ecosystem (registry, configuration)
- Higher integration effort than REST
==== spring-boot-rest-http-invoker
Advantages:
- Interface-based RPC over HTTP/JSON
- Minor changes in the code
Disadvantages:
- Community project to check maintenance status
- Not Spring standard
==== spring-rest-invoker
Advantages:
- Interface-based RPC over HTTP/JSON
- Low dependencies
Disadvantages:
- Releases in the repository a long time ago
- Check maintenance status
==== Hessian (Community Forks)
Advantages:
- Binary RPC protocol over HTTP
- Interface based usage
Disadvantages:
- Different maintenance status per fork
- Check license clarity per fork
==== gRPC
Advantages:
- High performance (HTTP/2, Protobuf)
- Cross-language, strong typing
Disadvantages:
- IDL (.proto) required, interface rewrite
- Higher migration effort
==== RSocket
Advantages:
- Reactive, bidirectional
- Spring integration available
Disadvantages:
- No HTTP transport, different operating model
- Interface-based RPC usage only with additional library
==== Apache CXF (Simple Frontend)
Advantages:
- SOAP based RPC approach over HTTP
- Java interface usable
Disadvantages:
- WSDL generation and SOAP stack increase complexity
- Mostly heavyweight for new remote APIs
=== Project decision and justification
The project relies on an RPC-style REST/MVC strategy (POST + `@RequestBody`) for the standard migration of `@Remote`. The choice is justified by Spring-native support, low additional dependencies and the ability to generate transformations deterministically. RPC-like alternatives (Dubbo, Hessian-Forks, rest-http-invoker) remain as options, but require additional dependencies and project-specific decisions.
OpenAPI is not automatically generated. The openapi generator generates code from an OpenAPI specification, but not a specification from Spring MVC controllers. Automatic spec generation requires additional tools (e.g. springdoc or swagger-core). This decision is made on a project-specific basis and is not the default of the migration.
=== Example
In EJB, remote calls are defined using an interface:
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Remote;

@Remote
public interface BookingGateway {
    BookingSummary load(BookingId id);
}
----

Instead, an explicit API layer is created in Spring:
.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class BookingGatewayController {

    private final BookingService bookingService;

    public BookingGatewayController(BookingService bookingService) {
        this.bookingService = bookingService;
    }

    @PostMapping("/api/BookingGateway/load")
    public BookingSummary load(@RequestBody BookingId id) {
        return bookingService.load(id);
    }
}
----

=== Automation in the project
The migration of `@Remote` interfaces is supported by several recipes. The strategy is over
`project.yaml` controlled.
==== Configuration (project.yaml)
[source,yaml]----
migration:
  remote:
    strategy: rest   # or: manual
----

[cols="1,2,2"]|===
| Wert | Description | Generated artifacts

| `rest` (Default)
| REST/MVC + @HttpExchange Client
| Controller, DTOs, Client-Interface, Client-Config

| `manual`
| Marker for manual migration
| @NeedsReview auf Interface
|===

==== Strategy: REST (default)
The REST strategy generates a complete RPC-like API over HTTP:
===== Generated artifacts
[cols="2.3"]|===
| Artifact | Description

| `{Interface}RestController`
| Spring MVC Controller with `@PostMapping` per method

| `{MethodName}Request` DTOs
| Request DTOs for methods with multiple parameters

| `{Interface}Client`
| Spring 6 `@HttpExchange` Client-Interface

| `{Interface}ClientConfig`
| `@Configuration` with `HttpServiceProxyFactory`
|===

===== Path schema
Individual methods get the path `/api/{Interface}/{method}`:
[source, java]----
@PostMapping("/api/SearchService/findById")
public Result findById(@RequestBody SearchByIdRequest request) { ... }
----

===== Overloaded methods (overloads)
For overloaded methods (same name, different parameters) a numeric suffix is used
appended to the path:
[source, java]----
// Interface: void search(String query)
//            void search(String query, int limit)
//            void search(SearchFilter filter)

@PostMapping("/api/SearchService/search/1")  // search(String)
@PostMapping("/api/SearchService/search/2")  // search(String, int)
@PostMapping("/api/SearchService/search/3")  // search(SearchFilter)
----

[IMPORTANT]====
Numbering is based on the **order in the source file** (source order).
Changing method order in the interface changes the generated paths.
This can break existing clients.
====

===== DTO naming scheme
DTOs are generated when a method has more than one parameter or the parameter
a primitive type is:
[cols="2,2"]|===
| Method | DTO name
| `findById(Long id)` (not overloaded)
| `FindByIdRequest`
| `search(String query)` (Overload 1)
| `Search1Request`
| `search(String query, int limit)` (Overload 2)
| `Search2Request`
| `search(SearchFilter filter)` (Overload 3)
| `Search3Request`
| `process(String name, Item... items)`
| `ProcessRequest` (Varargs als `Item[]`)|===

[NOTE]====
For overloaded methods, **all** variants receive numbering (`Search1Request`,
`Search2Request`, ...), not only the second and subsequent ones.
====

Varargs parameters are stored in DTOs as an array type (`Item[]` instead of `Item...`).
===== Client configuration
The generated client requires a base URL, which is configured via properties.
The property name follows the pattern `{interfaceName}.baseUrl` (camelCase):
[source, properties]----
# application.properties
searchService.baseUrl=http://localhost:8080
----

The configuration class reads this property:
[source, java]----
@Configuration
public class SearchServiceClientConfig {
    @Value("${searchService.baseUrl}")
    private String baseUrl;

    @Bean
    public SearchServiceClient searchServiceClient() {
        // HttpServiceProxyFactory setup...
    }
}
----

===== Implementation binding
The controller is connected to the specific implementation. The prioritization:
1. Class with `@Stateless` or `@Singleton` (EJB)
2nd class with `@Service` or `@Component` (Spring)
3. Only unannotated implementation
If there are no or multiple matching implementations, a controller stub is included
`@NeedsReview(category = REMOTE_ACCESS)` generated which requires manual customization.
==== Strategy: Manual
The manual strategy is intended for cases where automatic REST generation
is not suitable (e.g. complex security requirements, gRPC migration).
[source,yaml]----
migration:
  remote:
    strategy: manual
----

The recipe `MigrateRemoteToMarker`:
* **Removes** the `@Remote` annotation from the interface
* **Adds** `@NeedsReview(category = REMOTE_ACCESS)`
* **Does not generate** controllers or clients
.Example: Manual strategy
[source, java]----
// BEFORE
@Remote
public interface PaymentGateway { ... }

// AFTER
@NeedsReview(category = NeedsReview.Category.REMOTE_ACCESS,
             reason = "Remote interface requires manual migration to REST/gRPC")
public interface PaymentGateway { ... }
----

==== Legacy: Stub generator
The older stub generator still exists for compatibility:
* `com.github.rewrite.ejb.GenerateRemoteEjbStubs`
This only creates skeleton classes with `UnsupportedOperationException` and is intended for cases
in which full REST generation is not desired.
=== See also
* **Project configuration:** `docs/research/project-configuration-yaml.md` contains the complete
  Reference all `project.yaml` options including `migration.remote.strategy`.
* **Migration strategies:** Chapter “Migration strategies” describes general procedures
  (Big-Bang, Strangler, module-by-module migration).
* **JAX-RS:** Chapter "JAX-RS" documents the REST client migration with a similar choice of strategy.