== Jakarta Concurrency Utilities
Jakarta Concurrency provides container managed executor services (`ManagedExecutorService`, `ManagedScheduledExecutorService`). These services ensure context propagation and lifecycle management. No identical model exists in Spring Boot; Instead, `TaskExecutor`, `TaskScheduler` or your own executor beans are used.
=== ManagedExecutorService
.Example: BEFORE (Jakarta Concurrency)
[source, java]----
import javax.annotation.Resource;
import javax.enterprise.concurrent.ManagedExecutorService;

public class DocumentPipeline {

    @Resource
    private ManagedExecutorService executor;

    public void process(Document doc) {
        executor.submit(() -> handle(doc));
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.core.task.TaskExecutor;
import org.springframework.stereotype.Component;

@Component
public class DocumentPipeline {

    private final TaskExecutor taskExecutor;

    public DocumentPipeline(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    public void process(Document doc) {
        taskExecutor.execute(() -> handle(doc));
    }
}
----

In Spring, thread pools must be configured explicitly. Context passing (security, MDC, transactions) must be additionally implemented depending on the requirements.
The Jakarta concurrency specification describes that managed executors propagate container contexts such as JNDI naming, class loaders and security information. If you work outside of these managed executors, these contexts are lost. When migrating, it is therefore important to check which contexts were implicitly present in EJB operation and whether they need to be transferred explicitly to Spring.