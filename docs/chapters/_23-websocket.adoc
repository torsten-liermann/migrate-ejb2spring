== WebSocket

Jakarta WebSocket definiert Endpoints über `@ServerEndpoint` und optional `@OnOpen`, `@OnMessage`, `@OnClose`. Spring Boot verwendet das Spring-WebSocket-Modell mit `WebSocketHandler` oder `@MessageMapping` in Kombination mit STOMP. Die Migration muss den Kommunikationsstil, die Sessionverwaltung und das Threading neu bewerten.

.Spezifikationsreferenzen
****
* https://jakarta.ee/specifications/websocket/2.1/jakarta-websocket-spec-2.1.html[Jakarta WebSocket 2.1 Spec]
* https://jakarta.ee/specifications/websocket/2.1/jakarta-websocket-spec-2.1.html#server-endpoint[Jakarta WebSocket 2.1 - §3.1 @ServerEndpoint]
* https://jakarta.ee/specifications/websocket/2.1/jakarta-websocket-spec-2.1.html#messaging[Jakarta WebSocket 2.1 - Chapter 5: Messaging]
* https://docs.spring.io/spring-framework/reference/web/websocket.html[Spring WebSocket Reference]
****

=== ServerEndpoint zu Spring WebSocket

.Beispiel: VORHER (Jakarta WebSocket)
[source,java]
----
import javax.websocket.*;
import javax.websocket.server.ServerEndpoint;

@ServerEndpoint("/tracking")
public class TrackingEndpoint {

    @OnMessage
    public void onMessage(String payload, Session session) {
        handle(payload, session);
    }
}
----

.Beispiel: NACHHER (Spring WebSocket)
[source,java]
----
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

public class TrackingHandler extends TextWebSocketHandler {

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        handle(message.getPayload(), session);
    }
}
----

=== Messaging und STOMP

Wenn die Anwendung STOMP oder ein Message-Broker-Modell nutzt, empfiehlt sich die Verwendung von `@MessageMapping` und Spring Messaging. Das hat Auswirkungen auf Pfade, Payload-Formate und Security-Handling.

=== Migrationshinweise

Die Lebensdauer einer WebSocket-Session ist in Jakarta EE containerverwaltet. In Spring müssen Session-Attribute, Heartbeats und mögliche Skalierungsstrategien (z. B. WebSocket-Session-Replikation) explizit konfiguriert werden.

Die WebSocket‑Spezifikation beschreibt, dass pro verbundenem Peer eine Endpoint‑Instanz verwendet wird, sofern kein eigener Configurator eine andere Strategie definiert. Session‑User‑Properties bleiben bis zum `onClose` erhalten; in verteilten Containern müssen sie serialisierbar sein, damit eine Migration der Session möglich ist. Diese Semantik muss bei der Migration in Spring explizit berücksichtigt werden.

Wenn `@ServerEndpoint` in Spring Boot beibehalten wird, werden Endpoint‑Instanzen vom WebSocket‑Container erzeugt und nicht durch Spring. Spring‑Injection ist in diesem Fall nur über spezielle Configurator‑Mechanismen möglich und muss im Projekt explizit vorgesehen werden.

=== Automatisierte Migration

[cols="1,3"]
|===
| Name | `com.github.rewrite.ejb.MarkWebSocketForMigration`
| Beschreibung | Markiert `@ServerEndpoint`/`@ClientEndpoint`-Klassen mit `@NeedsReview(category=MANUAL_MIGRATION)`.
| Konfiguration | keine
|===

Siehe auch: link:../migration-guide/websocket-migration.md[WebSocket Migration Guide]
