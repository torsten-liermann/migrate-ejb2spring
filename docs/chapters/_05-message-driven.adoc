== Message Driven Beans
Message-Driven Beans (MDB) are EJBs for asynchronous message input. They are container-managed, configured via activation properties and run in a JMS context with transactions and redelivery semantics. In Spring this is represented by `@JmsListener` and listener container configuration. The semantics are similar, but not identical: configuration, redelivery strategy, acknowledge mode and error handling must be explicitly checked.
=== @MessageDriven -> @Component + @JmsListener
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.MessageDriven;
import javax.ejb.ActivationConfigProperty;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;
@MessageDriven(activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationType",
                              propertyValue = "javax.jms.Queue"),
    @ActivationConfigProperty(propertyName = "destinationLookup",
                              propertyValue = "jms/ShipmentQueue"),
    @ActivationConfigProperty(propertyName = "acknowledgeMode",
                              propertyValue = "Auto-acknowledge")
})
public class ShipmentListener implements MessageListener {
@EJB
    private ShipmentService shipmentService;
@Override
    public void onMessage(Message message) {
        if (message instanceof TextMessage textMessage) {
            ShipmentCommand cmd = parse(textMessage);
            shipmentService.register(cmd);
        }
    }
}----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
public class ShipmentListener {

    private final ShipmentService shipmentService;

    public ShipmentListener(ShipmentService shipmentService) {
        this.shipmentService = shipmentService;
    }

@JmsListener(destination = "ShipmentQueue")
    @Transactional
    public void onMessage(ShipmentCommand command) {
        shipmentService.register(command);
    }
}
----

[NOTE]====
The MDB activation properties must be mapped to listener container properties in Spring (Destination, Selector, Concurrency, Ack-Mode, Subscription). The exact keys vary depending on the provider and must be checked against the messaging infrastructure.====

The EJB specification allows additional activation properties such as `clientId`, `subscriptionDurability` and `messageSelector`. These values ​​are only effective in Spring if they are transferred to the concrete listener container configuration. A pure annotation migration without container configuration changes the runtime behavior.
.Example: application.yml
[source,yaml]----
spring:
  jms:
    listener:
      acknowledge-mode: auto
      concurrency: 5-10
----

=== Error handling and redelivery
EJB implements redelivery via transaction rollback and container strategies. Spring also uses transactions, but the redelivery strategy depends on the listener container and provider used.
The EJB specification describes that runtime exceptions in a message-driven bean transfer the bean instance to the “does not exist” state. `@PreDestroy` is not guaranteed in this case. Resources that are opened in `@PostConstruct` must therefore be managed in such a way that the failure of individual instances does not cause leaks.
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.MessageDriven;
import javax.ejb.ActivationConfigProperty;
import javax.annotation.Resource;
import javax.ejb.MessageDrivenContext;
import javax.jms.MessageListener;

@MessageDriven(activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationLookup",
                              propertyValue = "jms/InvoiceQueue")
})
public class InvoiceListener implements MessageListener {

    @Resource
    private MessageDrivenContext context;

    @Override
    public void onMessage(javax.jms.Message message) {
        try {
            processInvoice(message);
        } catch (Exception e) {
            context.setRollbackOnly();
        }
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

@Component
public class InvoiceListener {

    @JmsListener(destination = "InvoiceQueue")
    @Transactional
    public void onMessage(InvoiceCommand command) {
        processInvoice(command);
    }
}
----

[WARNING]====
Redelivery backoff, dead letter queues and acknowledge strategies are provider-dependent. The migration must explicitly check these settings and must not rely on default behavior.
====

=== Automated migration
[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateMessageDrivenToJmsListener`
| Description | Transforms `@MessageDriven` to `@Component` with `@JmsListener` on `onMessage` method.
| Configuration | no|===

[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateMessaging`
| Description | Combines `MigrateMessageDrivenToJmsListener` and `AddEnableJmsAndScheduling`.
| Configuration | none
|===

---
