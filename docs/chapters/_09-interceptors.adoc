== Interceptors
EJB interceptors are part of the container model and offer declarative cross-sectional functions such as logging, auditing or security checks. In Spring, this role is primarily taken over by Spring AOP, which works via proxy and defines pointcuts via annotations or signatures. What is crucial for the migration is which join points are actually reached and how the call order is mapped to EJB interceptor chains.
=== @Interceptors and @AroundInvoke
.Example: BEFORE (EJB)
[source, java]----
import javax.interceptor.Interceptor;
import javax.interceptor.AroundInvoke;
import javax.interceptor.InvocationContext;
import javax.interceptor.Interceptors;

@Interceptor
public class AuditInterceptor {

    @AroundInvoke
    public Object audit(InvocationContext ctx) throws Exception {
        AuditEntry entry = AuditEntry.start(ctx.getMethod().getName());
        try {
            return ctx.proceed();
        } finally {
            entry.finish();
        }
    }
}

@Stateless
@Interceptors(AuditInterceptor.class)
public class TariffCalculationService {

    public Money calculateTariff(Shipment shipment) {
        return compute(shipment);
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class AuditAspect {

    @Around("@within(org.springframework.stereotype.Service)")
    public Object audit(ProceedingJoinPoint joinPoint) throws Throwable {
        AuditEntry entry = AuditEntry.start(joinPoint.getSignature().getName());
        try {
            return joinPoint.proceed();
        } finally {
            entry.finish();
        }
    }
}
----

Spring AOP works proxy-based and only uses the proxy for external calls. Self-calls within a class are not intercepted. EJB interceptors, on the other hand, are applied by the container for each interceptor-bound call. This must be taken into account for migrations with internal call chains.
=== Interceptor bindings from CDI
CDI uses `@InterceptorBinding` to bind interceptors via its own annotation. In Spring, this is usually represented by its own annotation and an `@Aspect`, which reacts to the annotation as a pointcut.
.Example: BEFORE (CDI)
[source, java]----
import javax.interceptor.InterceptorBinding;
import java.lang.annotation.*;

@InterceptorBinding
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface Audited { }
----

.Example: AFTER (Spring Boot)
[source, java]----
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface Audited { }

@Aspect
@Component
public class AuditedAspect {

    @Around("@annotation(Audited) || @within(Audited)")
    public Object audit(ProceedingJoinPoint joinPoint) throws Throwable {
        return joinPoint.proceed();
    }
}
----

The order of multiple interceptors in EJB is determined by priorities and `@Interceptors` order. In Spring, the order can be controlled with `@Order` or `Ordered`.