== Deepening
This chapter is aimed at teams who want to understand the migration not only technically, but also architecturally. The focus is on the differences between the programming models, not the syntax of the annotations.
EJB relies on container-managed services: transactions, security, concurrency and remoting are part of the runtime model. Spring Boot delivers similar functionality through a combination of DI, AOP, and configuration that needs to be controlled more explicitly. This shifts responsibility for consistency and operational behavior more to the application and its configuration.
A typical deep dive involves the service layer. In EJB, services are often strongly tied to the container, for example through `@Startup`, `@Lock`, `@RunAs` or JNDI lookups. In Spring, each of these tasks must be evaluated individually: `@Startup` requires a start event, `@Lock` requires synchronization, `@RunAs` requires conscious security configuration, and JNDI becomes property binding. This decomposition makes the logic comprehensible, but only if the technical requirements are documented.
A second deep dive concerns asynchronous processing. In EJB, `@Asynchronous`, `@MessageDriven` and `TimerService` are integral parts of the container. In Spring these are separate building blocks with their own configuration. This affects threading, error handling and monitoring. A migration without this consideration leads to apparently working code that produces unexpected latencies or incorrect states during operation.