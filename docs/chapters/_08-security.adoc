== Security
EJB security is declaratively embedded in the container model. Roles, run-as semantics and access control are implemented by the application server and are closely linked to the identity and context model. In Spring Boot, the same specialized logic is typically secured via Spring Security, but with a different model for expressions, role names, and context propagation. A migration must therefore check both the annotations and the semantic evaluation.
.Specification references****
* https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html[Jakarta Security 3.0 Spec]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a1593[Jakarta EJB 4.0 Spec - ยง10.6 Security]
* https://jakarta.ee/specifications/annotations/2.1/jakarta-annotations-spec-2.1.html#declaresroles[Jakarta Annotations 2.1 - @DeclareRoles]
* https://docs.spring.io/spring-security/reference/servlet/authorization/method-security.html[Spring Security - Method Security]
****

=== Role-based access
EJB works with `@RolesAllowed`, `@PermitAll` and `@DenyAll`. In Spring Security this corresponds to Method Security with `@PreAuthorize` or `@Secured`. `@PreAuthorize` allows SpEL expressions that evaluate parameters and security context.
.Example: BEFORE (EJB)
[source, java]----
import javax.annotation.security.RolesAllowed;
import javax.annotation.security.PermitAll;
import javax.annotation.security.DenyAll;
import javax.ejb.Stateless;

@Stateless
@RolesAllowed({"ACCOUNT_ADMIN", "ACCOUNT_AGENT"})
public class CustomerAccountService {

    @PermitAll
    public AccountSummary viewPublicProfile(AccountId accountId) {
        return loadSummary(accountId);
    }

    @RolesAllowed("ACCOUNT_ADMIN")
    public void closeAccount(AccountId accountId) {
        close(accountId);
    }

    @DenyAll
    public void internalReconcile(AccountId accountId) {
        reconcile(accountId);
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;

@Service
@PreAuthorize("hasAnyRole('ACCOUNT_ADMIN','ACCOUNT_AGENT')")
public class CustomerAccountService {

    @PreAuthorize("permitAll()")
    public AccountSummary viewPublicProfile(AccountId accountId) {
        return loadSummary(accountId);
    }

    @PreAuthorize("hasRole('ACCOUNT_ADMIN')")
    public void closeAccount(AccountId accountId) {
        close(accountId);
    }

    @PreAuthorize("denyAll()")
    public void internalReconcile(AccountId accountId) {
        reconcile(accountId);
    }
}
----

Method Security must be activated explicitly in Spring, for example via `@EnableMethodSecurity`. Role prefixes (`ROLE_`) and authority names should be checked as EJB and Spring use different conventions.
=== Security domain and role mapping
In WildFly/EAP, roles are often assigned via security domains or Elytron configurations. These assignments are defined outside the application code and affect EJB method checks. In Spring Boot, these roles must be provided via the security stack (Authentication Provider, JWT/LDAP mapping, `GrantedAuthorities`). The migration therefore requires an explicit role mapping from the server configuration to a Spring Security configuration.
=== Run-As and impersonation
`@RunAs` is an EJB-specific concept for role-based impersonation within the container. There is no direct counterpart with the same semantics in Spring Security. The security context change occurs via `SecurityContextHolder` or via a separate service layer with elevated rights. When migrating, it must be clarified whether the technical purpose of `@RunAs` can be represented by a technical service boundary or a separate system account.
=== Note on context propagation
EJB calls within the same container propagate security context. In Spring, this depends on the mechanism chosen, such as asynchronous processing or messaging. With `@Async` or `@JmsListener` it must be checked whether a SecurityContext exists and whether it is actively propagated.
By default, the security context is not automatically propagated for WebSocket handlers and scheduled jobs. If the EJB code relies on `SessionContext.getCallerPrincipal()` or `isCallerInRole()`, a technical alternative must be defined for these execution paths.
=== Automated migration
[cols="1.3"]|===
| Name | Description

| `com.github.rewrite.ejb.RemoveJBossSecurityDomain`
| Removes `@org.jboss.ejb3.annotation.SecurityDomain` annotations (JBoss-specific, no Spring equivalent).
|===
