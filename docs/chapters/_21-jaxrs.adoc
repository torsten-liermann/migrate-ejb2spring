== JAX-RS
JAX-RS defines resources, paths, and content negotiation for REST APIs. In Spring Boot, this functionality is provided by Spring MVC or WebFlux. The migration affects resource classes, parameter binding, exception mapping and filter/interceptor mechanisms.
.Specification references****
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html[Jakarta RESTful Web Services 3.1 Spec]
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#resources[Jakarta REST 3.1 - Chapter 3: Resources]
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#providers[Jakarta REST 3.1 - Chapter 4: Providers]
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#client_api[Jakarta REST 3.1 - Chapter 5: Client API]****

=== Resources and paths
JAX-RS uses `@Path`, `@GET`, `@POST` and parameter annotations. Spring MVC uses `@RestController`, `@RequestMapping` and specific mapping annotations. Path and media types can usually be transferred directly, but default conventions differ (e.g. trailing slashes, MediaType prioritization).
By default, the JAX-RS specification defines a per-request lifetime for resources. Implementations may offer other lifecycles; However, the specification indicates that field and property injection is only intended for the default lifecycle. If singleton resources are used in the project, the injection of @Context fields and similar dependencies must be checked.
.Example: BEFORE (JAX-RS)
[source, java]----
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/shipments")
@Produces(MediaType.APPLICATION_JSON)
public class ShipmentResource {

    @GET
    @Path("/{id}")
    public ShipmentDetails get(@PathParam("id") String id) {
        return load(id);
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/shipments")
public class ShipmentController {

    @GetMapping("/{id}")
    public ShipmentDetails get(@PathVariable String id) {
        return load(id);
    }
}
----

=== Exception and filter handling
JAX-RS uses `ExceptionMapper`, `ContainerRequestFilter` and `ContainerResponseFilter`. In Spring, `@ControllerAdvice`, `HandlerInterceptor` and Filter are the equivalents. Migrations should exactly inherit existing HTTP status codes and error formats as they are part of the API contract.
`@Context` injection (e.g. `UriInfo`, `SecurityContext`) is standardized in JAX‑RS. In Spring, access to request context is solved via method parameters (`HttpServletRequest`, `Principal`) or via `RequestContextHolder`. There is no direct 1:1 transfer; The target access must be defined per endpoint.
=== JAX-RS Client
JAX-RS Client APIs can be replaced with Spring `RestClient`, `WebClient` or further with a JAX-RS Client. The choice depends on existing features such as client filtering, authentication and response streaming.
=== Server operation with JAX-RS providers (keep-jaxrs)
If `keep-jaxrs` is chosen, the server-side JAX-RS implementation is preserved. An explicit provider choice is required in Spring Boot because Spring itself does not provide a JAX-RS server. The providers differ in deployment mechanics, servlet registration, filter chain and JSON-B/JSON processing. The selection must be made for each project and documented in the configuration.
The migration differentiates between **client-side provider** (dependencies for JAX-RS client) and **server-side provider** (runtime integration in the Spring Boot context). The current status only automates the client-side dependencies; The server-side provider integration is planned as a separate expansion.
==== Provider overview (server side)
[cols="1,2,2"]|===
| Providers | Spring support | Note for migration

| Jersey
| Spring Boot offers an official integration via `spring-boot-starter-jersey`.
| Suitable if JAX-RS is to be retained on the server side and boot-native integration is desired.

| RESTEasy
| Integration occurs via RESTEasy projects/starters, not Spring Boot itself.
| Requires explicit servlet registration and dependencies; Behavior must be checked on a provider-specific basis.

| CXF
| Integration takes place via Apache CXF (Spring Boot Starter or your own configuration).
| Suitable for projects with CXF bindings or shared JAX-RS/JAX-WS infrastructure.
|===

The choice of provider influences the technical implementation (servlet registration, JSON-B/JSON-Jackson Bridge, filter chain). For a stable migration, the provider decision is part of the project architecture and must be documented.
==== Selection criteria and Spring integration
At least the following criteria must be documented when choosing a provider:
- existing provider usage in the project (dependencies, configuration, specific classes)
- required features (filter/interceptor, JSON-B/JSON-Jackson, exception mapping)
- desired operating mode (servlet registration, path layout, integration into Spring context)
Each provider has its own integration mechanisms. Spring Boot does not provide a generic JAX-RS server; The integration is provider-dependent. The migration therefore requires a clear decision as to which integration will be used in the target project.
.Provider documentation****
* https://eclipse-ee4j.github.io/jersey/[Jersey Documentation]
* https://resteasy.dev/[RESTEasy Documentation]
* https://cxf.apache.org/[Apache CXF Documentation]
****

=== Configuration via project.yaml
The JAX‑RS server and client strategies are configured in `project.yaml`. If the file is missing, JAX‑RS is retained by default (server and client). A deviation from the default (e.g. `manual`) requires an explicit specification in `project.yaml`.
[source,yaml]----
jaxrs:
  strategy: keep-jaxrs | migrate-to-spring-mvc
  server:
    provider: jersey | resteasy | cxf
    basePath: /api        # Base path for JAX-RS endpoints (default: /api)
  client:
    strategy: keep-jaxrs | manual | migrate-restclient | migrate-webclient
    provider: jersey | resteasy | cxf
    providerVersion: "3.1.5"----

Server strategy:
- `keep-jaxrs`: JAX-RS server annotations remain unchanged, the server recipes do not migrate.
- `migrate-to-spring-mvc`: enables the server recipes for `@Path`, HTTP methods, parameter binding and `Response` migration.
- `keep-jaxrs` also requires a server provider (`jaxrs.server.provider`) so that the runtime integration is clear.
Client strategy:
- `keep-jaxrs`: JAX‑RS client remains, provider dependencies are added.
- `manual`: JAX-RS client usage is marked with `@NeedsReview` and `@Profile("manual-migration")`.
- `migrate-restclient` and `migrate-webclient` are currently not implemented; the run falls back to `manual` and generates a warning.
- Current implementation status in recipe `com.github.rewrite.ejb.MigrateJaxRsClient`: `keep-jaxrs` and `manual` are effective, `migrate-restclient`/`migrate-webclient` lead to `manual`.
Recipe options (`MigrateJaxRsClient` and the server recipes) override `project.yaml` if explicitly set.
=== Recipe: MigrateJaxRsClient
[cols="1.3"]|===
| Name | `com.github.rewrite.ejb.MigrateJaxRsClient`
| Description | Adds JAX‑RS client runtime dependencies or creates review markers.
| Configuration | see below
|===

.Configuration options MigrateJaxRsClient
[cols="1,1,3"]|===
| option | Type | Description

| `strategy`
| `String`
| `manual` (creates review marks) or `keep-jaxrs` (adds provider dependencies). Default: `keep-jaxrs` (if `project.yaml` is missing)

| `provider`
| `String`
| JAX-RS provider for `keep-jaxrs`: `jersey`, `resteasy`, `cxf`. Default: `jersey`

| `providerVersion`
| `String`
| Version of the provider dependencies. Optional, uses built-in defaults.
|===

=== Recipe: GenerateJaxRsServerConfig
[cols="1.3"]|===
| Name | `com.github.rewrite.ejb.GenerateJaxRsServerConfig`
| Description | Generates provider-specific JAX-RS server configuration for Spring Boot.
| Prerequisite | `jaxrs.strategy: keep-jaxrs` (default)
|===

The recipe scans all `@Path` annotated classes in the module and generates an appropriate Spring Boot configuration based on the chosen provider.
.Configuration Options GenerateJaxRsServerConfig
[cols="1,1,3"]|===
| option | Type | Description

| `jaxrs.server.provider`
| `String`
| JAX-RS Providers: `jersey` (default), `resteasy`, `cxf`. If the information is missing, the provider is recognized from Maven dependencies.

| `jaxrs.server.basePath`
| `String`
| Base path for all endpoints. Default: `/api`
|===

==== Provider implementations
[cols="1,3,2"]|===
| Provider | Generated configuration | Dependency

| Jersey
| `JerseyConfiguration extends ResourceConfig` with `@Component` + `@ApplicationPath`
| `spring-boot-starter-jersey:3.4.1`

| RESTEasy
| `ResteasyConfiguration extends Application` with `@ApplicationPath`
| `resteasy-servlet-spring-boot-starter:6.3.0.Final`

| CXF
| `CxfJaxrsConfiguration` with `@Configuration` + `@Bean JAXRSServerFactoryBean`
| `cxf-spring-boot-starter-jaxrs:4.1.4`
|===

==== Provider auto detection
If no explicit provider is configured, the provider is automatically detected from the Maven dependencies. The detection uses the effective Maven model (MavenResolutionResult) with fallback to string-based POM search.
If **multiple providers are detected**, automatic generation is not carried out. Instead, a `@NeedsReview` comment is created in the POM with recommendations for action.
==== Existing Config Detection
The recipe detects existing configurations and skips generation:
- Classes with names like `*JerseyConfig*`, `*ResteasyConfig*`, `*CxfConfig*`
- Classes with `@Configuration` that use `ResourceConfig` or `JAXRSServerFactoryBean`
- Classes that extend `jakarta.ws.rs.core.Application` or `javax.ws.rs.core.Application`
- Classes with `@ApplicationPath` annotation (jakarta or javax namespace)
.Example: Generated Jersey configuration
[source, java]----
package com.example.api;

import jakarta.ws.rs.ApplicationPath;
import org.glassfish.jersey.server.ResourceConfig;
import org.springframework.stereotype.Component;

@Component
@ApplicationPath("/api")
public class JerseyConfiguration extends ResourceConfig {

    public JerseyConfiguration() {
        register(com.example.api.UserResource.class);
        register(com.example.api.OrderResource.class);
    }
}
----

=== More JAX-RS recipes
[cols="1.3"]|===
| Name | Description
| `com.github.rewrite.ejb.MigrateJaxRsAnnotations`
| Migrates `@Path`, `@GET/@POST/@PUT/@DELETE` to Spring MVC annotations.
| `com.github.rewrite.ejb.MigrateJaxRsParameterAnnotations`
| Migrates `@PathParam`, `@QueryParam`, `@HeaderParam` to Spring equivalents.
| `com.github.rewrite.ejb.MigrateJaxRsResponseToResponseEntity`
| Migrates `javax.ws.rs.core.Response` to `ResponseEntity<T>`.|===
