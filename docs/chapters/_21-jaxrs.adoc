== JAX-RS

JAX-RS definiert Ressourcen, Pfade und Content-Negotiation für REST-APIs. In Spring Boot wird diese Funktionalität durch Spring MVC oder WebFlux bereitgestellt. Die Migration betrifft Ressourcenklassen, Parameterbindung, Exception-Mapping und Filter/Interceptor-Mechanismen.

.Spezifikationsreferenzen
****
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html[Jakarta RESTful Web Services 3.1 Spec]
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#resources[Jakarta REST 3.1 - Chapter 3: Resources]
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#providers[Jakarta REST 3.1 - Chapter 4: Providers]
* https://jakarta.ee/specifications/restful-ws/3.1/jakarta-restful-ws-spec-3.1.html#client_api[Jakarta REST 3.1 - Chapter 5: Client API]
****

=== Ressourcen und Pfade

JAX-RS verwendet `@Path`, `@GET`, `@POST` und Parameter-Annotationen. Spring MVC nutzt `@RestController`, `@RequestMapping` und spezifische Mapping-Annotationen. Pfad- und Medien-Typen lassen sich meist direkt übertragen, jedoch unterscheiden sich Default-Konventionen (z. B. Trailing Slashes, MediaType-Priorisierung).

Die JAX‑RS‑Spezifikation definiert für Ressourcen standardmäßig eine Per‑Request‑Lebensdauer. Implementierungen dürfen andere Lifecycles anbieten; die Spezifikation weist jedoch darauf hin, dass Feld‑ und Property‑Injection nur für den Default‑Lifecycle vorgesehen ist. Wenn im Projekt Singleton‑Ressourcen genutzt werden, ist die Injection von `@Context`‑Feldern und ähnlichen Abhängigkeiten zu prüfen.

.Beispiel: VORHER (JAX-RS)
[source,java]
----
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;

@Path("/shipments")
@Produces(MediaType.APPLICATION_JSON)
public class ShipmentResource {

    @GET
    @Path("/{id}")
    public ShipmentDetails get(@PathParam("id") String id) {
        return load(id);
    }
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/shipments")
public class ShipmentController {

    @GetMapping("/{id}")
    public ShipmentDetails get(@PathVariable String id) {
        return load(id);
    }
}
----

=== Exception- und Filter-Handling

JAX-RS nutzt `ExceptionMapper`, `ContainerRequestFilter` und `ContainerResponseFilter`. In Spring sind `@ControllerAdvice`, `HandlerInterceptor` und Filter die Entsprechungen. Migrationen sollten bestehende HTTP-Statuscodes und Fehlerformate exakt übernehmen, da sie Teil des API-Vertrags sind.

`@Context`‑Injection (z. B. `UriInfo`, `SecurityContext`) ist in JAX‑RS standardisiert. In Spring wird der Zugriff auf Request‑Kontext über Method‑Parameter (`HttpServletRequest`, `Principal`) oder über `RequestContextHolder` gelöst. Eine direkte 1:1‑Übernahme existiert nicht; der Zielzugriff ist pro Endpunkt zu definieren.

=== JAX-RS Client

JAX-RS Client APIs können durch Spring `RestClient`, `WebClient` oder weiterhin durch einen JAX-RS Client ersetzt werden. Die Wahl hängt von bestehenden Features wie Client-Filtern, Authentifizierung und Response-Streaming ab.

=== Serverbetrieb mit JAX-RS Providern (keep-jaxrs)

Wenn `keep-jaxrs` gewählt wird, bleibt die serverseitige JAX-RS Implementierung erhalten. In Spring Boot ist dafür eine explizite Provider-Wahl erforderlich, weil Spring selbst keinen JAX-RS Server mitliefert. Die Provider unterscheiden sich in Deployment-Mechanik, Servlet-Registrierung, Filterkette und JSON-B/JSON-Verarbeitung. Die Auswahl muss pro Projekt getroffen und in der Konfiguration dokumentiert werden.

Die Migration unterscheidet dabei zwischen **clientseitigem Provider** (Dependencies für JAX-RS Client) und **serverseitigem Provider** (Runtime-Integration im Spring Boot Kontext). Der aktuelle Stand automatisiert nur die clientseitigen Dependencies; die serverseitige Provider-Integration ist als separater Ausbau vorgesehen.

==== Provider-Überblick (serverseitig)

[cols="1,2,2"]
|===
| Provider | Spring-Unterstützung | Bemerkung für die Migration

| Jersey
| Spring Boot bietet eine offizielle Integration über `spring-boot-starter-jersey`.
| Geeignet, wenn JAX-RS serverseitig beibehalten werden soll und eine Boot-native Integration gewünscht ist.

| RESTEasy
| Integration erfolgt über RESTEasy-Projekte/Starter, nicht über Spring Boot selbst.
| Erfordert explizite Servlet-Registrierung und Abhängigkeiten; Verhalten ist provider-spezifisch zu prüfen.

| CXF
| Integration erfolgt über Apache CXF (Spring Boot Starter oder eigene Konfiguration).
| Geeignet für Projekte mit CXF-Bindings oder gemeinsamer JAX-RS/JAX-WS Infrastruktur.
|===

Die Provider-Wahl beeinflusst die technische Umsetzung (Servlet-Registrierung, JSON-B/JSON-Jackson Bridge, Filter-Kette). Für eine stabile Migration ist die Provider-Entscheidung Teil der Projektarchitektur und muss dokumentiert werden.

==== Auswahlkriterien und Spring-Integration

Für die Provider-Wahl sind mindestens folgende Kriterien zu dokumentieren:

- vorhandene Provider-Nutzung im Projekt (Dependencies, Konfiguration, spezifische Klassen)
- benötigte Features (Filter/Interceptor, JSON-B/JSON-Jackson, Exception-Mapping)
- gewünschter Betriebsmodus (Servlet-Registrierung, Pfad-Layout, Integration in Spring-Kontext)

Jeder Provider bringt eigene Integrationsmechanismen mit. Spring Boot stellt keinen generischen JAX‑RS‑Server zur Verfügung; die Einbindung erfolgt providerabhängig. Für die Migration ist daher eine klare Entscheidung erforderlich, welche Integration im Zielprojekt genutzt wird.

.Provider-Dokumentation
****
* https://eclipse-ee4j.github.io/jersey/[Jersey Documentation]
* https://resteasy.dev/[RESTEasy Documentation]
* https://cxf.apache.org/[Apache CXF Documentation]
****

=== Konfiguration über project.yaml

Die JAX‑RS‑Server‑ und Client‑Strategien werden in `project.yaml` konfiguriert. Fehlt die Datei, wird JAX‑RS standardmäßig beibehalten (Server und Client). Eine Abweichung vom Default (z. B. `manual`) erfordert eine explizite Angabe in `project.yaml`.

[source,yaml]
----
jaxrs:
  strategy: keep-jaxrs | migrate-to-spring-mvc
  server:
    provider: jersey | resteasy | cxf
    basePath: /api        # Base path für JAX-RS Endpoints (Default: /api)
  client:
    strategy: keep-jaxrs | manual | migrate-restclient | migrate-webclient
    provider: jersey | resteasy | cxf
    providerVersion: "3.1.5"
----

Server‑Strategie:

- `keep-jaxrs`: JAX‑RS‑Server‑Annotationen bleiben unverändert, die Server‑Rezepte führen keine Migration durch.
- `migrate-to-spring-mvc`: aktiviert die Server‑Rezepte für `@Path`, HTTP‑Methoden, Parameter‑Binding und `Response`‑Migration.
- `keep-jaxrs` setzt zusätzlich einen Server‑Provider voraus (`jaxrs.server.provider`), damit die Runtime‑Integration eindeutig ist.

Client‑Strategie:

- `keep-jaxrs`: JAX‑RS Client bleibt, Provider‑Dependencies werden hinzugefügt.
- `manual`: JAX‑RS‑Client‑Nutzung wird mit `@NeedsReview` und `@Profile("manual-migration")` markiert.
- `migrate-restclient` und `migrate-webclient` sind derzeit nicht implementiert; der Lauf fällt auf `manual` zurück und erzeugt eine Warnung.
- Aktueller Implementierungsstand im Rezept `com.github.rewrite.ejb.MigrateJaxRsClient`: `keep-jaxrs` und `manual` sind wirksam, `migrate-restclient`/`migrate-webclient` führen zu `manual`.

Rezept‑Optionen (`MigrateJaxRsClient` und die Server‑Rezepte) überschreiben `project.yaml`, sofern sie explizit gesetzt sind.

=== Rezept: MigrateJaxRsClient

[cols="1,3"]
|===
| Name | `com.github.rewrite.ejb.MigrateJaxRsClient`
| Beschreibung | Fügt JAX‑RS‑Client‑Runtime‑Abhängigkeiten hinzu oder erzeugt Review‑Markierungen.
| Konfiguration | siehe unten
|===

.Konfigurationsoptionen MigrateJaxRsClient
[cols="1,1,3"]
|===
| Option | Typ | Beschreibung

| `strategy`
| `String`
| `manual` (erzeugt Review‑Markierungen) oder `keep-jaxrs` (fügt Provider‑Dependencies hinzu). Default: `keep-jaxrs` (wenn `project.yaml` fehlt)

| `provider`
| `String`
| JAX-RS Provider bei `keep-jaxrs`: `jersey`, `resteasy`, `cxf`. Default: `jersey`

| `providerVersion`
| `String`
| Version der Provider-Dependencies. Optional, nutzt eingebaute Defaults.
|===

=== Rezept: GenerateJaxRsServerConfig

[cols="1,3"]
|===
| Name | `com.github.rewrite.ejb.GenerateJaxRsServerConfig`
| Beschreibung | Generiert provider-spezifische JAX-RS Server-Konfiguration für Spring Boot.
| Voraussetzung | `jaxrs.strategy: keep-jaxrs` (Default)
|===

Das Rezept scannt alle `@Path`-annotierten Klassen im Modul und generiert eine passende Spring Boot Konfiguration basierend auf dem gewählten Provider.

.Konfigurationsoptionen GenerateJaxRsServerConfig
[cols="1,1,3"]
|===
| Option | Typ | Beschreibung

| `jaxrs.server.provider`
| `String`
| JAX-RS Provider: `jersey` (Default), `resteasy`, `cxf`. Bei fehlender Angabe wird der Provider aus Maven-Dependencies erkannt.

| `jaxrs.server.basePath`
| `String`
| Base path für alle Endpoints. Default: `/api`
|===

==== Provider-Implementierungen

[cols="1,3,2"]
|===
| Provider | Generierte Konfiguration | Dependency

| Jersey
| `JerseyConfiguration extends ResourceConfig` mit `@Component` + `@ApplicationPath`
| `spring-boot-starter-jersey:3.4.1`

| RESTEasy
| `ResteasyConfiguration extends Application` mit `@ApplicationPath`
| `resteasy-servlet-spring-boot-starter:6.3.0.Final`

| CXF
| `CxfJaxrsConfiguration` mit `@Configuration` + `@Bean JAXRSServerFactoryBean`
| `cxf-spring-boot-starter-jaxrs:4.1.4`
|===

==== Provider Auto-Detection

Wenn kein expliziter Provider konfiguriert ist, wird der Provider automatisch aus den Maven-Dependencies erkannt. Die Erkennung nutzt das effektive Maven-Modell (MavenResolutionResult) mit Fallback auf String-basierte POM-Suche.

Bei **mehreren erkannten Providern** wird keine automatische Generierung durchgeführt. Stattdessen wird ein `@NeedsReview`-Kommentar im POM erzeugt mit Handlungsempfehlungen.

==== Existing Config Detection

Das Rezept erkennt vorhandene Konfigurationen und überspringt die Generierung:

- Klassen mit Namen wie `*JerseyConfig*`, `*ResteasyConfig*`, `*CxfConfig*`
- Klassen mit `@Configuration` die `ResourceConfig` oder `JAXRSServerFactoryBean` nutzen
- Klassen die `jakarta.ws.rs.core.Application` oder `javax.ws.rs.core.Application` erweitern
- Klassen mit `@ApplicationPath` Annotation (jakarta oder javax Namespace)

.Beispiel: Generierte Jersey-Konfiguration
[source,java]
----
package com.example.api;

import jakarta.ws.rs.ApplicationPath;
import org.glassfish.jersey.server.ResourceConfig;
import org.springframework.stereotype.Component;

@Component
@ApplicationPath("/api")
public class JerseyConfiguration extends ResourceConfig {

    public JerseyConfiguration() {
        register(com.example.api.UserResource.class);
        register(com.example.api.OrderResource.class);
    }
}
----

=== Weitere JAX-RS Rezepte

[cols="1,3"]
|===
| Name | Beschreibung

| `com.github.rewrite.ejb.MigrateJaxRsAnnotations`
| Migriert `@Path`, `@GET/@POST/@PUT/@DELETE` zu Spring MVC Annotationen.

| `com.github.rewrite.ejb.MigrateJaxRsParameterAnnotations`
| Migriert `@PathParam`, `@QueryParam`, `@HeaderParam` zu Spring-Äquivalenten.

| `com.github.rewrite.ejb.MigrateJaxRsResponseToResponseEntity`
| Migriert `javax.ws.rs.core.Response` zu `ResponseEntity<T>`.
|===
