== JNDI
EJB applications often include resources using JNDI names, such as DataSources, JMS destinations or configuration values. In Spring Boot, these values ​​are captured in `application.properties` or `application.yml` and injected via property binding. The migration is therefore always a configuration migration.
=== JNDI bound resources
JNDI names reflect the container configuration. They need to be translated into concrete property names in Spring Boot. For DataSources this is usually `spring.datasource.*`, for JMS destinations it is often a separate `@ConfigurationProperties` class.
In the project, JNDI lookups are recognized by the recipes and marked with `@NeedsReview`. The specific assignment to properties depends on the existing server configuration and must be validated on a project-specific basis.
.Example: BEFORE (EJB)
[source, java]
----
import javax.annotation.Resource;
import javax.sql.DataSource;

public class BillingRepository {

    @Resource(lookup = "java:app/jdbc/BillingDataSource")
    private DataSource dataSource;
}
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.stereotype.Repository;

@Repository
public class BillingRepository {

    private final DataSource dataSource;

    public BillingRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
----

The actual linking takes place via configuration:
.Example: application.properties
[source, properties]
----
spring.datasource.url=jdbc:postgresql://localhost:5432/billing
spring.datasource.username=billing
spring.datasource.password=secret
----

=== Configuration values
JNDI can also be used in EJB for simple strings or flags. In Spring this should be replaced with `@ConfigurationProperties` to have a clear, typed configuration.
=== JMS resources
JMS ConnectionFactory and Destinations are often bound via JNDI in EJB. In Spring Boot, ConnectionFactories are usually created via starter configuration and controlled via properties. Destinations are typically used as string names in @JmsListener and need to be matched to messaging configurations. The migration requires a consistent mapping of JNDI names to properties and listener configurations.