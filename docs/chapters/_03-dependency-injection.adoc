== Dependency Injection
Dependency injection in EJB is tightly coupled to the container: the instance is created, the container injects dependencies into fields or setters and then calls `@PostConstruct`. Constructor injection is not provided in EJB. Spring, on the other hand, relies on constructor injection as the default and uses proxies for cross-sectional functions. These influences where initialization and validation are meaningfully placed.
=== @EJB -> Constructor Injection
`@EJB` typically represents local EJB references within the same application. In Spring, the same relationship is represented as normal bean injection. EJB `lookup` via JNDI has no direct equivalent in the standard Spring model; Depending on the architecture, an explicit remote adapter is necessary.
.Example: BEFORE (EJB)
[source, java]
----
import javax.ejb.Stateless;
import javax.ejb.EJB;
@Stateless
public class OrderController {
@EJB
    private OrderService orderService;
@EJB(beanName = "primaryCustomerService")
    private CustomerService customerService;
@EJB(lookup = "java:global/app/PaymentService")
    private PaymentService paymentService;
}
----
.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Qualifier;
@Component
public class OrderController {
private final OrderService orderService;
    private final CustomerService customerService;
    private final PaymentService paymentService;
public OrderController(
            OrderService orderService,
            @Qualifier("primaryCustomerService") CustomerService customerService,
            PaymentService paymentService) {
        this.orderService = orderService;
        this.customerService = customerService;
        this.paymentService = paymentService;
    }
}
----

[NOTE]
====
`@EJB(lookup=...)` is a JNDI based reference. In Spring this can only be replaced if an equivalent bean exists in the same context. An explicit adapter (REST, Messaging, gRPC) is required for true remote access.
====

=== @Inject (CDI) -> Constructor Injection
CDI `@Inject` is semantically similar to Spring DI, but the scopes differ in details. When migrating, it is important that Spring does not adopt any implicit CDI features such as qualifier metadata or producers by default.
.Example: BEFORE (CDI (Jakarta EE))
[source, java]
----
import javax.inject.Inject;
import javax.inject.Named;
import javax.enterprise.context.RequestScoped;

@RequestScoped
@Named
public class CheckoutController {

    @Inject
    private ShoppingCart cart;

    @Inject
    @Named("expressPayment")
    private PaymentProcessor paymentProcessor;
}
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.stereotype.Controller;
import org.springframework.web.context.annotation.RequestScope;
import org.springframework.beans.factory.annotation.Qualifier;
@Controller
@RequestScope
public class CheckoutController {
private final ShoppingCart cart;
    private final PaymentProcessor paymentProcessor;
public CheckoutController(
            ShoppingCart cart,
            @Qualifier("expressPayment") PaymentProcessor paymentProcessor) {
        this.cart = cart;
        this.paymentProcessor = paymentProcessor;
    }
}
----

=== @Resource -> @Autowired / @Value / @ConfigurationProperties
`@Resource` is used in EJB for both local services and JNDI bound resources. In Spring, the target type needs to be distinguished:
==== @Resource for local services
.Example: BEFORE (EJB)
[source, java]
----
import javax.annotation.Resource;
import javax.ejb.Stateless;

@Stateless
public class NotificationService {

    @Resource
    private EmailService emailService;
}
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.stereotype.Service;
@Service
public class NotificationService {
private final EmailService emailService;
public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }
}
----

==== @Resource for DataSource
.Example: BEFORE (EJB)
[source, java]
----
import javax.annotation.Resource;
import javax.sql.DataSource;

@Stateless
public class ReportService {

    @Resource(name = "jdbc/reportingDS")
    private DataSource dataSource;
}
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.stereotype.Service;
import javax.sql.DataSource;
@Service
public class ReportService {
private final DataSource dataSource;
public ReportService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
----

==== @Resource for configuration
.Example: JNDI configuration in EJB
[source, java]
----
@Resource(name = "java:app/config/TaxRate")
private BigDecimal taxRate;
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.beans.factory.annotation.Value;
@Value("${tax.rate}")
private BigDecimal taxRate;
----

[NOTE]
====
Configuration in Spring is explicit (Properties/YAML or `@ConfigurationProperties`). JNDI configuration must be mapped as properties or transferred to a separate configuration layer.
====

=== Automated migration
[cols="1.3"]
|===
| Name | `de.example.rewrite.ejb.MigrateEjbToAutowired`
| Description | Transforms `@EJB` to `@Autowired`.
| Configuration | no
|===

[cols="1.3"]
|===
| Name | `de.example.rewrite.ejb.MigrateInjectToAutowired`
| Description | Transforms `@Inject` to `@Autowired`.
| Configuration | none
|===

[cols="1.3"]
|===
| Name | `de.example.rewrite.ejb.MigrateDependencyInjection`
| Description | Combines `MigrateEjbToAutowired` and `MigrateInjectToAutowired`.
| Configuration | no
|===

---
