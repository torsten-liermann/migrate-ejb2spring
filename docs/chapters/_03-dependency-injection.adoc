== Dependency Injection

Dependency Injection ist in EJB eng an den Container gekoppelt: die Instanz wird erzeugt, der Container injiziert Abhängigkeiten in Felder oder Setter und ruft anschließend `@PostConstruct` auf. Konstruktorinjektion ist in EJB nicht vorgesehen. Spring setzt dagegen auf Konstruktorinjektion als Standard und verwendet Proxies für Querschnittsfunktionen. Das beeinflusst, wo Initialisierung und Validierung sinnvoll platziert werden.

=== @EJB -> Constructor Injection

`@EJB` steht typischerweise für lokale EJB-Referenzen innerhalb derselben Anwendung. In Spring wird dieselbe Beziehung als normale Bean-Injektion abgebildet. Für EJB-`lookup` über JNDI gibt es im Spring-Standardmodell keine direkte Entsprechung; je nach Architektur ist ein expliziter Remote-Adapter notwendig.

.Beispiel: VORHER (EJB)
[source,java]
----
import javax.ejb.Stateless;
import javax.ejb.EJB;

@Stateless
public class OrderController {

    @EJB
    private OrderService orderService;

    @EJB(beanName = "primaryCustomerService")
    private CustomerService customerService;

    @EJB(lookup = "java:global/app/PaymentService")
    private PaymentService paymentService;
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Component;
import org.springframework.beans.factory.annotation.Qualifier;

@Component
public class OrderController {

    private final OrderService orderService;
    private final CustomerService customerService;
    private final PaymentService paymentService;

    public OrderController(
            OrderService orderService,
            @Qualifier("primaryCustomerService") CustomerService customerService,
            PaymentService paymentService) {
        this.orderService = orderService;
        this.customerService = customerService;
        this.paymentService = paymentService;
    }
}
----

[NOTE]
====
`@EJB(lookup=...)` ist ein JNDI-basierter Verweis. In Spring ist das nur dann ersetzbar, wenn ein äquivalenter Bean im gleichen Kontext existiert. Für echte Remote-Zugriffe ist ein expliziter Adapter (REST, Messaging, gRPC) erforderlich.
====

=== @Inject (CDI) -> Constructor Injection

CDI `@Inject` ist semantisch ähnlich zu Spring DI, aber die Scopes unterscheiden sich in Details. In der Migration ist wichtig, dass Spring standardmäßig keine impliziten CDI-Features wie Qualifier-Metadaten oder Producer übernimmt.

.Beispiel: VORHER (CDI (Jakarta EE))
[source,java]
----
import javax.inject.Inject;
import javax.inject.Named;
import javax.enterprise.context.RequestScoped;

@RequestScoped
@Named
public class CheckoutController {

    @Inject
    private ShoppingCart cart;

    @Inject
    @Named("expressPayment")
    private PaymentProcessor paymentProcessor;
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Controller;
import org.springframework.web.context.annotation.RequestScope;
import org.springframework.beans.factory.annotation.Qualifier;

@Controller
@RequestScope
public class CheckoutController {

    private final ShoppingCart cart;
    private final PaymentProcessor paymentProcessor;

    public CheckoutController(
            ShoppingCart cart,
            @Qualifier("expressPayment") PaymentProcessor paymentProcessor) {
        this.cart = cart;
        this.paymentProcessor = paymentProcessor;
    }
}
----

=== @Resource -> @Autowired / @Value / @ConfigurationProperties

`@Resource` wird in EJB sowohl für lokale Dienste als auch für JNDI-gebundene Ressourcen verwendet. In Spring muss der Zieltyp unterschieden werden:

==== @Resource für lokale Services

.Beispiel: VORHER (EJB)
[source,java]
----
import javax.annotation.Resource;
import javax.ejb.Stateless;

@Stateless
public class NotificationService {

    @Resource
    private EmailService emailService;
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Service;

@Service
public class NotificationService {

    private final EmailService emailService;

    public NotificationService(EmailService emailService) {
        this.emailService = emailService;
    }
}
----

==== @Resource für DataSource

.Beispiel: VORHER (EJB)
[source,java]
----
import javax.annotation.Resource;
import javax.sql.DataSource;

@Stateless
public class ReportService {

    @Resource(name = "jdbc/reportingDS")
    private DataSource dataSource;
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Service;
import javax.sql.DataSource;

@Service
public class ReportService {

    private final DataSource dataSource;

    public ReportService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
----

==== @Resource für Konfiguration

.Beispiel: JNDI-Konfiguration in EJB
[source,java]
----
@Resource(name = "java:app/config/TaxRate")
private BigDecimal taxRate;
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.beans.factory.annotation.Value;

@Value("${tax.rate}")
private BigDecimal taxRate;
----

[NOTE]
====
Konfiguration in Spring ist explizit (Properties/YAML oder `@ConfigurationProperties`). JNDI-Konfiguration muss als Properties abgebildet oder in eine separate Konfigurationsschicht überführt werden.
====

=== Automatisierte Migration

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigrateEjbToAutowired`
| Beschreibung | Transformiert `@EJB` zu `@Autowired`.
| Konfiguration | keine
|===

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigrateInjectToAutowired`
| Beschreibung | Transformiert `@Inject` zu `@Autowired`.
| Konfiguration | keine
|===

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigrateDependencyInjection`
| Beschreibung | Kombiniert `MigrateEjbToAutowired` und `MigrateInjectToAutowired`.
| Konfiguration | keine
|===

---
