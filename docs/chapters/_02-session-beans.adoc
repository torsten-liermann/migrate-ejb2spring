== Session Beans
Session beans encapsulate technical application logic.
When it comes to migration, it's not just the annotation that counts, but the semantics: lifecycle, concurrency, state and transactions.
EJB defines a container-centric model with clear guarantees for invocation, transactions, concurrency and lifecycle.
Spring works with dependency injection and AOP proxies and expects many rules to be implemented explicitly.
A clean migration describes these differences and shows how they are consciously mapped in Spring.
=== @Stateless -> Spring Service (stateless)
A `@Stateless` bean is intended for short business operations that do not maintain a conversation state between calls (e.g. booking, release, availability check).
EJB guarantees that an instance will not be called in parallel, but makes no promises about instance identity or reuse.
Instance state beyond the method call is not allowed.
Spring does not have an equivalent session bean model.
Services are usually created as a singleton and shared over the entire runtime.
The container does not create a new service instance per call.
Migration therefore requires a conscious separation of stateless logic and state, explicit thread safety and clearly drawn transaction boundaries.
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Stateless;
import javax.ejb.EJB;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
@Stateless
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public class FreightBookingService {
@EJB
    private BookingRepository bookingRepository;
@EJB
    private CapacityService capacityService;
public BookingId book(ShipmentRequest request) {
        capacityService.assertCapacity(request);
        return bookingRepository.createBooking(request);
    }
}----
.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
@Service
@Transactional
public class FreightBookingService {
private final BookingRepository bookingRepository;
    private final CapacityService capacityService;
public FreightBookingService(BookingRepository bookingRepository,
                                 CapacityService capacityService) {
        this.bookingRepository = bookingRepository;
        this.capacityService = capacityService;
    }
public BookingId book(ShipmentRequest request) {
        capacityService.assertCapacity(request);
        return bookingRepository.createBooking(request);
    }
}----

EJB injection is typically done via fields or setters and is only available after construction.
That's why initialization is often in `@PostConstruct`.
In Spring, the preferred way is constructor injection; Initialization belongs in the constructor or in an explicit init method. `@PostConstruct` remains possible, but is not the default pattern.
[TIP]====
Transaction mapping (short version):
* `@TransactionAttribute(REQUIRED)` -> `@Transactional`
* `REQUIRES_NEW` -> `@Transactional(propagation = REQUIRES_NEW)`
* `SUPPORTS` -> `@Transactional(propagation = SUPPORTS)`
Details and exception rules (checked vs. unchecked) are described in the transaction chapter.====

[CAUTION]====
Concurrency and instance state

EJB guarantees that the same instance will not be called in parallel.
This is not a license for instance state.
Instance variables may not carry a call state; This is technically incorrect in EJB and leads directly to race conditions in Spring.

.Example (problematic): Stateful in @Stateless
[source,java]
----
@Stateless
public class TariffCalculationService {
    private Money tempTotal;
public Money calculate(Shipment shipment) {
        this.tempTotal = computeBase(shipment);
        return this.tempTotal.plus(computeSurcharges(shipment));
    }
}----

Use local variables or explicitly thread-safe structures.
====

=== @Stateless with attributes
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Stateless;
@Stateless(name = "rateEngine", description = "Calculates freight rates")
public class RateEngineBean {
}----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.stereotype.Service;

/**
 * Calculates freight rates
 */
@Service("rateEngine")
public class RateEngineBean {
}
----

[NOTE]====
`@Stateless(name=...)` was often associated with JNDI names in EJB.
In Spring, the string is just the bean name, not a JNDI alias.====
=== @Singleton -> @Service
EJB singletons are used for shared technical resources (reference data, rules, caches).
The container guarantees one instance per application and provides explicit concurrency semantics with `@Lock`. `@Startup` controls initialization.
Additionally, lifecycle callbacks such as `@PostConstruct` and `@PreDestroy` are part of the EJB model.
`@DependsOn` can be used to control the initialization order between singletons.
In Spring, a `@Service` bean is also a singleton, but without these concurrency semantics.
Locking must be explicitly recreated. `@PostConstruct`/`@PreDestroy` exist, but do not cover all EJB callbacks.
The automatic migration transforms `@Startup` + `@PostConstruct` to `@EventListener(ApplicationReadyEvent.class)`, which corresponds to the EJB specification: initialization before the first client request (EJB Spec 4.8.1).
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.annotation.PostConstruct;
@Singleton
@Startup
public class ReferenceDataCache {
private Map<String, TariffRule> rules;
@PostConstruct
    public void init() {
        rules = loadRules();
    }
@Lock(LockType.READ)
    public TariffRule findRule(String key) {
        return rules.get(key);
    }
@Lock(LockType.WRITE)
    public void refresh() {
        rules = loadRules();
    }
}----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.stereotype.Service;
import org.springframework.context.event.EventListener;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

@Service
public class ReferenceDataCache {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private Map<String, TariffRule> rules;

    @EventListener(ApplicationReadyEvent.class)
    public void init() {
        rules = loadRules();
    }

    public TariffRule findRule(String key) {
        lock.readLock().lock();
        try {
            return rules.get(key);
        } finally {
            lock.readLock().unlock();
        }
    }

    public void refresh() {
        lock.writeLock().lock();
        try {
            rules = loadRules();
        } finally {
            lock.writeLock().unlock();
        }
    }
}
----

[WARNING]====
@Lock has no direct Spring equivalent. `@Lock(READ/WRITE)` must be deliberately replaced (e.g. `ReentrantReadWriteLock`, `synchronized`, atomic structures).
A `ConcurrentHashMap` does not replace the write semantics of a `@Lock(WRITE)`.====

[NOTE]====
@Startup will be migrated automatically
The migration automatically transforms `@Startup` + `@PostConstruct` to `@EventListener(ApplicationReadyEvent.class)`.
This corresponds to the EJB specification (4.8.1): "the container must initialize the singleton session bean instance during the application startup sequence [...] before any external client requests are delivered."
Additional Spring mechanisms are available for manual migration:
* Simple initialization without startup guarantee: `@PostConstruct`
* Non-transactional startup logic: `ApplicationRunner`
* Start logic with transaction: `@EventListener(ApplicationReadyEvent.class)` + `@Transactional`====

[NOTE]====
@DependsOn is migrated automatically

`@DependsOn` from `jakarta.ejb` is transformed to `@DependsOn` from `org.springframework.context.annotation`.
The semantics remain identical: controlling the initialization order between beans.
====

=== @Stateful -> Explicit state architecture
`@Stateful` models technical conversation states (e.g. draft offer, claims processing, shopping cart).
The container can passivate/activate and end a conversation with `@Remove`.
These lifecycle callbacks (`@PrePassivate`, `@PostActivate`) have no direct counterpart in Spring.
The condition must be consciously remodeled.
The target mapping depends on the client context. HTTP-based calls can be modeled using session or request scopes. Remote clients, messaging or batch triggers do not have an HTTP session and require other forms of state management.
Transaction boundaries and resource commitment must be explicitly checked. EJB transactions are method-related; Conversation state must not rely on open resources. If state is stored outside of the JVM, it must be serializable and separate from infrastructure resources.
Migration is therefore an architectural decision.
Two typical alternatives are:
.Example: Option A (Session-Scoped Bean)
[source, java]----
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.SessionScope;
@Component
@SessionScope
public class QuoteDraft {
private List<QuoteLine> lines = new ArrayList<>();
public void addLine(QuoteLine line) {
        lines.add(line);
    }
public Quote finalizeQuote() {
        return new Quote(lines);
    }
}----
.Example: Option B (Persistent Draft)
[source, java]----
import org.springframework.stereotype.Service;
@Service
public class QuoteDraftService {
private final QuoteDraftRepository repository;
public QuoteDraftService(QuoteDraftRepository repository) {
        this.repository = repository;
    }
public DraftId startDraft(CustomerId customerId) {
        QuoteDraft draft = QuoteDraft.start(customerId);
        return repository.save(draft);
    }
public void addLine(DraftId draftId, QuoteLine line) {
        QuoteDraft draft = repository.load(draftId);
        draft.addLine(line);
        repository.save(draft);
    }
public Quote finalizeDraft(DraftId draftId) {
        QuoteDraft draft = repository.load(draftId);
        Quote quote = draft.finalizeQuote();
        repository.delete(draftId);
        return quote;
    }
}----

[IMPORTANT]====
Architecture decision required:
[cols="1,2,2"]|===
| Option | Advantages | Disadvantages

| `@SessionScope`
| Close to EJB conversation model
| Only suitable with web sessions; limited scalability

| Persistent draft
| Robust, cluster-capable, auditable
| More modeling/repository logic required

| Stateless + explicit state transfer
| Clear, testable, scalable
| More data flow through the API
|===
====

[WARNING]====
Critical points for @Stateful migration

1. `@Remove` must be replaced explicitly (e.g., deleting/completing the draft).
2. `@PrePassivate`/`@PostActivate` correspond to serialization/deserialization; there is no direct Spring equivalent.
3. Serialization is required only when state is stored externally or replicated.
4. `@StatefulTimeout` describes idle times of the bean instance, not HTTP session timeout.
5. The client context determines the target mapping; HTTP session scopes are unsuitable for remote or batch clients.
====

=== Automated migration
[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateStatelessToService`
| Description | Transforms `@Stateless` to `@Service`. Removes `@LocalBean`.
| Configuration | no|===

[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateSingletonToService`
| Description | Transforms `@Singleton` to `@Service`. Transforms `@Startup` + `@PostConstruct` to `@EventListener(ApplicationReadyEvent.class)`. Transforms `@DependsOn` from `jakarta.ejb` to `org.springframework.context.annotation`. Removes `@Lock` and `@ConcurrencyManagement` with a `@NeedsReview` marker for explicit locking.
| Configuration | none
|===

[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateSessionBeans`
| Description | Combines `MigrateStatelessToService` and `MigrateSingletonToService`.
| Configuration | no|===

---
