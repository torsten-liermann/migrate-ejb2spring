== Session Beans
Session beans encapsulate business application logic. In migration work, the critical factor is not the annotation itself but the runtime semantics: lifecycle, concurrency, state, and transaction boundaries.

EJB defines a container-centric model with explicit guarantees for invocation behavior, transaction handling, concurrency, and lifecycle callbacks. Spring uses dependency injection and proxy-based AOP, and requires several of these rules to be implemented explicitly in application code and configuration.

=== @Stateless -> Spring Service (stateless)
A `@Stateless` bean is intended for short business operations without conversational state between calls, for example booking, release, or availability checks.

EJB guarantees that the same instance is not invoked concurrently, but it does not guarantee instance identity or reuse semantics that application code can rely on. State beyond method scope is not part of the model.

Spring has no direct equivalent of the EJB session-bean model. Services are typically singleton beans shared across runtime. Migration therefore requires explicit separation of stateless logic and state handling, explicit thread-safety decisions, and clear transaction boundaries.

.Example: BEFORE (EJB)
[source,java]
----
import javax.ejb.Stateless;
import javax.ejb.EJB;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;

@Stateless
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public class FreightBookingService {

    @EJB
    private BookingRepository bookingRepository;

    @EJB
    private CapacityService capacityService;

    public BookingId book(ShipmentRequest request) {
        capacityService.assertCapacity(request);
        return bookingRepository.createBooking(request);
    }
}
----

.Example: AFTER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@Transactional
public class FreightBookingService {

    private final BookingRepository bookingRepository;
    private final CapacityService capacityService;

    public FreightBookingService(BookingRepository bookingRepository,
                                 CapacityService capacityService) {
        this.bookingRepository = bookingRepository;
        this.capacityService = capacityService;
    }

    public BookingId book(ShipmentRequest request) {
        capacityService.assertCapacity(request);
        return bookingRepository.createBooking(request);
    }
}
----

EJB injection is typically field- or setter-based and is available only after construction. For this reason, initialization logic is often placed in `@PostConstruct`.

In Spring, constructor injection is the preferred pattern. Initialization belongs in the constructor or in an explicit initialization method. `@PostConstruct` remains available, but it is not the default design pattern for new code.

[TIP]
====
Transaction mapping (short version):

* `@TransactionAttribute(REQUIRED)` -> `@Transactional`
* `REQUIRES_NEW` -> `@Transactional(propagation = REQUIRES_NEW)`
* `SUPPORTS` -> `@Transactional(propagation = SUPPORTS)`

Details and exception rules (checked vs. unchecked) are described in the transactions chapter.
====

[CAUTION]
====
Concurrency and instance state

EJB guarantees non-concurrent access to the same instance. This is not a license to keep conversational state in instance fields.

Instance variables must not carry request state. This is already an architectural defect in EJB and becomes an immediate race-condition risk after migration to singleton Spring services.

.Example (problematic): state in `@Stateless`
[source,java]
----
@Stateless
public class TariffCalculationService {

    private Money tempTotal;

    public Money calculate(Shipment shipment) {
        this.tempTotal = computeBase(shipment);
        return this.tempTotal.plus(computeSurcharges(shipment));
    }
}
----

Use local variables or explicitly thread-safe state handling.
====

=== @Stateless with attributes
.Example: BEFORE (EJB)
[source,java]
----
import javax.ejb.Stateless;

@Stateless(name = "rateEngine", description = "Calculates freight rates")
public class RateEngineBean {
}
----

.Example: AFTER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Service;

/**
 * Calculates freight rates.
 */
@Service("rateEngine")
public class RateEngineBean {
}
----

[NOTE]
====
`@Stateless(name=...)` was often tied to JNDI naming conventions in EJB deployments.

In Spring, the string value is a bean name, not a JNDI alias.
====

=== @Singleton -> @Service
EJB singletons are frequently used for shared technical resources such as reference data, rules, and caches. The container provides single-instance semantics with explicit concurrency control via `@Lock`. `@Startup` controls eager startup behavior.

Lifecycle callbacks such as `@PostConstruct` and `@PreDestroy` are part of the EJB lifecycle model. `@DependsOn` can define startup ordering between singletons.

In Spring, `@Service` is singleton by default, but without EJB concurrency semantics. Locking must be implemented explicitly. `@PostConstruct` and `@PreDestroy` exist, but they do not replicate all EJB lifecycle semantics.

The automated migration in this project transforms `@Startup` + `@PostConstruct` to `@EventListener(ApplicationReadyEvent.class)`, aligned with EJB startup intent.

.Example: BEFORE (EJB)
[source,java]
----
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.annotation.PostConstruct;

@Singleton
@Startup
public class ReferenceDataCache {

    private Map<String, TariffRule> rules;

    @PostConstruct
    public void init() {
        rules = loadRules();
    }

    @Lock(LockType.READ)
    public TariffRule findRule(String key) {
        return rules.get(key);
    }

    @Lock(LockType.WRITE)
    public void refresh() {
        rules = loadRules();
    }
}
----

.Example: AFTER (Spring Boot)
[source,java]
----
import org.springframework.stereotype.Service;
import org.springframework.context.event.EventListener;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

@Service
public class ReferenceDataCache {

    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private Map<String, TariffRule> rules;

    @EventListener(ApplicationReadyEvent.class)
    public void init() {
        rules = loadRules();
    }

    public TariffRule findRule(String key) {
        lock.readLock().lock();
        try {
            return rules.get(key);
        } finally {
            lock.readLock().unlock();
        }
    }

    public void refresh() {
        lock.writeLock().lock();
        try {
            rules = loadRules();
        } finally {
            lock.writeLock().unlock();
        }
    }
}
----

[WARNING]
====
`@Lock` has no direct Spring equivalent. `@Lock(READ/WRITE)` must be replaced explicitly, for example with `ReentrantReadWriteLock`, `synchronized`, or atomic/concurrent structures where semantically valid.

`ConcurrentHashMap` alone does not replicate `@Lock(WRITE)` semantics.
====

[NOTE]
====
`@Startup` is migrated automatically.

The migration transforms `@Startup` + `@PostConstruct` to `@EventListener(ApplicationReadyEvent.class)`.

Additional Spring startup mechanisms remain available for manual design choices:

* `@PostConstruct` for basic initialization
* `ApplicationRunner` for startup logic without transactional semantics
* `@EventListener(ApplicationReadyEvent.class)` + `@Transactional` for startup logic with explicit transaction scope
====

[NOTE]
====
`@DependsOn` is migrated automatically.

`@DependsOn` from `jakarta.ejb` is transformed to `@DependsOn` from `org.springframework.context.annotation`.

The semantic intent remains startup ordering between beans.
====

=== @Stateful -> explicit state architecture
`@Stateful` models conversational state, for example draft offers, claim handling, or cart-style workflows.

The container can passivate/activate and terminate conversations via `@Remove`. Lifecycle callbacks such as `@PrePassivate` and `@PostActivate` have no direct Spring equivalent.

Target mapping depends on client context. HTTP-driven clients can map to request/session state. Remote, messaging, and batch clients do not have HTTP session context and require a different state model.

Transaction boundaries and resource handling must be reviewed explicitly. If state is externalized, serialization and storage semantics must be designed intentionally.

Two common target alternatives:

.Example: Option A (session-scoped bean)
[source,java]
----
import org.springframework.stereotype.Component;
import org.springframework.web.context.annotation.SessionScope;

@Component
@SessionScope
public class QuoteDraft {

    private List<QuoteLine> lines = new ArrayList<>();

    public void addLine(QuoteLine line) {
        lines.add(line);
    }

    public Quote finalizeQuote() {
        return new Quote(lines);
    }
}
----

.Example: Option B (persistent draft)
[source,java]
----
import org.springframework.stereotype.Service;

@Service
public class QuoteDraftService {

    private final QuoteDraftRepository repository;

    public QuoteDraftService(QuoteDraftRepository repository) {
        this.repository = repository;
    }

    public DraftId startDraft(CustomerId customerId) {
        QuoteDraft draft = QuoteDraft.start(customerId);
        return repository.save(draft);
    }

    public void addLine(DraftId draftId, QuoteLine line) {
        QuoteDraft draft = repository.load(draftId);
        draft.addLine(line);
        repository.save(draft);
    }

    public Quote finalizeDraft(DraftId draftId) {
        QuoteDraft draft = repository.load(draftId);
        Quote quote = draft.finalizeQuote();
        repository.delete(draftId);
        return quote;
    }
}
----

[IMPORTANT]
====
Architecture decision required:

[cols="1,2,2"]
|===
| Option | Advantages | Disadvantages

| `@SessionScope`
| Close to the EJB conversation model
| Suitable only for web sessions; limited scalability

| Persistent draft
| Robust, cluster-capable, auditable
| Additional modeling and repository complexity

| Stateless + explicit state transfer
| Clear, testable, scalable
| More data flow through APIs
|===
====

[WARNING]
====
Critical points for `@Stateful` migration:

1. `@Remove` must be replaced explicitly, for example by explicit completion/deletion operations.
2. `@PrePassivate`/`@PostActivate` correspond to serialization/deserialization events; there is no direct Spring equivalent.
3. Serialization is required only when state is externalized or replicated.
4. `@StatefulTimeout` describes bean-instance idle time, not HTTP session timeout.
5. Client context determines target mapping; HTTP session scopes are unsuitable for remote or batch clients.
====

=== Automated migration
[cols="1.3"]
|===
| Name | `de.example.rewrite.ejb.MigrateStatelessToService`
| Description | Transforms `@Stateless` to `@Service`. Removes `@LocalBean`.
| Configuration | none
|===

[cols="1.3"]
|===
| Name | `de.example.rewrite.ejb.MigrateSingletonToService`
| Description | Transforms `@Singleton` to `@Service`, transforms `@Startup` + `@PostConstruct` to `@EventListener(ApplicationReadyEvent.class)`, transforms `@DependsOn` from `jakarta.ejb` to `org.springframework.context.annotation`, and removes `@Lock`/`@ConcurrencyManagement` with `@NeedsReview` markers for explicit locking follow-up.
| Configuration | none
|===

[cols="1.3"]
|===
| Name | `de.example.rewrite.ejb.MigrateSessionBeans`
| Description | Combines `MigrateStatelessToService` and `MigrateSingletonToService`.
| Configuration | none
|===

---
