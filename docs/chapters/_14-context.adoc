== Context
EJB provides context objects such as SessionContext, EJBContext, or MessageDrivenContext that provide access to security information, transactions, and resources. In Spring, comparable information is retrieved from the SecurityContext, from the TransactionManager or from the web environment. A direct exchange of APIs is not possible; the technical intent must be remodeled.
=== SessionContext and security
In EJB the current user is queried via the `SessionContext`. In Spring Security this is done via `SecurityContextHolder` and the `Authentication` object.
.Example: BEFORE (EJB)
[source, java]----
import javax.annotation.Resource;
import javax.ejb.SessionContext;
import javax.ejb.Stateless;

@Stateless
public class CustomerService {

    @Resource
    private SessionContext sessionContext;

    public CustomerProfile profile(CustomerId id) {
        String user = sessionContext.getCallerPrincipal().getName();
        return loadProfile(user, id);
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

@Service
public class CustomerService {

    public CustomerProfile profile(CustomerId id) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String user = auth.getName();
        return loadProfile(user, id);
    }
}
----

=== Transactions and rollback
EJB allows access to transaction status via context. In Spring, this status is expressed via `TransactionSynchronizationManager` or through exception handling. The use should be critically examined, as direct context queries are often an indicator of a lack of technical boundaries.
=== Resources and JNDI
`SessionContext.lookup()` and direct JNDI lookups are replaced by property binding in Spring. Resources are injected via `@ConfigurationProperties` or `@Value` and are no longer resolved directly via JNDI in the code.