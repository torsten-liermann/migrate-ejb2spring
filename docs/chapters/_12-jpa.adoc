== JPA
JPA is often included in EJB applications through persistence.xml, @PersistenceContext, and container-managed transactions. In Spring Boot, JPA is mostly configured through `spring-boot-starter-data-jpa`, where `application.properties` is the central configuration source. The migration affects not only the annotations, but also data sources, transaction boundaries and the interaction between repositories and EntityManager.
=== EntityManager injection
EJB uses `@PersistenceContext` and gets a container managed `EntityManager`. In Spring, the `EntityManager` can still be injected via `@PersistenceContext`, but Spring data repositories are also available to simplify access.
.Example: BEFORE (EJB)
[source, java]----
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.ejb.Stateless;

@Stateless
public class BookingRepository {

    @PersistenceContext
    private EntityManager em;

    public Booking find(BookingId id) {
        return em.find(Booking.class, id);
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.springframework.stereotype.Repository;

@Repository
public class BookingRepository {

    @PersistenceContext
    private EntityManager em;

    public Booking find(BookingId id) {
        return em.find(Booking.class, id);
    }
}
----

=== persistence.xml to Spring configuration
In EJB applications, `persistence.xml` defines the persistence unit name, provider, data source and specific JPA properties. In Spring Boot, these values ​​are transferred to `application.properties` or `application.yml`, typically as `spring.jpa.*` and `spring.datasource.*`. Differences in provider behavior must be taken into account, especially if EclipseLink was used and Spring Boot uses Hibernate by default.
`persistence.xml` can add or overwrite annotations, for example in `@NamedQuery` definitions or provider-specific properties. These overrides must be recorded in the migration and transferred to the Spring configuration if `persistence.xml` is omitted.
=== Extended Persistence Context
The JPA specification allows a `PersistenceContextType.EXTENDED`, which is tied to the lifetime of a stateful session bean and only ends at `@Remove`. There is no direct counterpart for this in Spring. If the application relies on an extended context, the state must be explicitly transferred to a business conversation or its own EntityManager management.
The following applies to the standard case: The transaction-scoped persistence context ends with commit or rollback. Calls outside an active transaction result in loaded entities being detached at the end of the method call. These semantics are identical in Spring, but are often obscured by repository abstractions. For migrations with lazy loading or long conversations, it must be checked whether an extended context was used implicitly.
=== Transaction limits
EJB uses container-managed transactions and determines context per method call. In Spring this is done via `@Transactional`. The transaction behavior only remains identical if the propagation and rollback rules are transferred cleanly. Additionally, the proxy model affects internal method calls: a `@Transactional` method called internally by the same class will not start a new transaction.
=== Automated migration
[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigratePersistenceXmlToProperties`
| Description | Extracts JPA configuration from `persistence.xml` and creates `application.properties`.
| Configuration | no
|===

[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigratePersistence`
| Description | Combines all persistence recipes.
| Configuration | none
|===
