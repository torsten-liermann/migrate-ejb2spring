== JPA

JPA ist in EJB-Anwendungen häufig über `persistence.xml`, `@PersistenceContext` und containerverwaltete Transaktionen eingebunden. In Spring Boot wird JPA meist durch `spring-boot-starter-data-jpa` konfiguriert, wobei `application.properties` die zentrale Konfigurationsquelle ist. Die Migration betrifft nicht nur die Annotationen, sondern auch Datenquellen, Transaktionsgrenzen und das Zusammenspiel von Repositorys und EntityManager.

=== EntityManager-Injektion

EJB nutzt `@PersistenceContext` und erhält einen containerverwalteten `EntityManager`. In Spring kann der `EntityManager` über `@PersistenceContext` weiterhin injiziert werden, allerdings stehen zusätzlich Spring-Data-Repositories zur Verfügung, die den Zugriff vereinfachen.

.Beispiel: VORHER (EJB)
[source,java]
----
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.ejb.Stateless;

@Stateless
public class BookingRepository {

    @PersistenceContext
    private EntityManager em;

    public Booking find(BookingId id) {
        return em.find(Booking.class, id);
    }
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.springframework.stereotype.Repository;

@Repository
public class BookingRepository {

    @PersistenceContext
    private EntityManager em;

    public Booking find(BookingId id) {
        return em.find(Booking.class, id);
    }
}
----

=== persistence.xml zu Spring-Konfiguration

In EJB-Anwendungen definiert `persistence.xml` den Persistence-Unit-Namen, den Provider, die DataSource und spezifische JPA-Properties. In Spring Boot werden diese Werte in `application.properties` oder `application.yml` überführt, typischerweise als `spring.jpa.*` und `spring.datasource.*`. Dabei müssen Unterschiede im Provider-Verhalten beachtet werden, insbesondere wenn EclipseLink genutzt wurde und Spring Boot standardmäßig Hibernate verwendet.

`persistence.xml` kann Annotationen ergänzen oder überschreiben, etwa bei `@NamedQuery`‑Definitionen oder Provider‑spezifischen Properties. Diese Overrides sind in der Migration zu erfassen und in Spring‑Konfiguration zu überführen, wenn `persistence.xml` entfällt.

=== Extended Persistence Context

Die JPA-Spezifikation erlaubt einen `PersistenceContextType.EXTENDED`, der an die Lebensdauer einer Stateful Session Bean gebunden ist und erst bei `@Remove` endet. In Spring gibt es dafür kein direktes Gegenstück. Wenn die Anwendung auf einen extended context angewiesen ist, muss der Zustand explizit in eine fachliche Konversation oder eine eigene EntityManager-Verwaltung überführt werden.

Für den Standardfall gilt: Der transaction‑scoped Persistence Context endet mit Commit oder Rollback. Aufrufe außerhalb einer aktiven Transaktion führen dazu, dass geladene Entitäten am Ende des Methodenaufrufs detacht sind. Diese Semantik ist in Spring identisch, wird aber häufig durch Repository‑Abstraktionen verdeckt. Bei Migrationen mit Lazy‑Loading oder langen Konversationen muss geprüft werden, ob ein Extended‑Context implizit genutzt wurde.

=== Transaktionsgrenzen

EJB verwendet containerverwaltete Transaktionen und bestimmt den Kontext pro Methodenaufruf. In Spring geschieht dies über `@Transactional`. Das Transaktionsverhalten bleibt nur dann identisch, wenn die Propagation und Rollback-Regeln sauber übertragen werden. Außerdem wirkt sich das Proxy-Modell auf interne Methodenaufrufe aus: eine `@Transactional`-Methode, die intern von derselben Klasse aufgerufen wird, startet keine neue Transaktion.

=== Automatisierte Migration

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigratePersistenceXmlToProperties`
| Beschreibung | Extrahiert JPA-Konfiguration aus `persistence.xml` und erzeugt `application.properties`.
| Konfiguration | keine
|===

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigratePersistence`
| Beschreibung | Kombiniert alle Persistenz-Rezepte.
| Konfiguration | keine
|===
