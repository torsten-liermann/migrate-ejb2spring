== Timer service
EJB Timer Service provides container-managed, transactional, and optionally persistent timing.
Semantics include calendar timers (`@Schedule`), programmatic timers (`TimerService`) and lifecycle integration (`@Timeout`).
Spring provides `@Scheduled` and `TaskScheduler`, but without a direct equivalent for EJB persistence and timer info.
Migration requires a conscious decision about persistence, cluster behavior and transaction boundaries.
This chapter covers both declarative timers (`@Schedule/@Timeout`) and programmatic timers (`TimerService`).
.Specification references***** https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a2881[Jakarta EJB 4.0 Spec - Chapter 18: Timer Service]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a2940[Jakarta EJB 4.0 Spec - §18.2.1 @Schedule/@Schedules]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a2983[Jakarta EJB 4.0 Spec - §18.2.2 Calendar-Based Timer Expressions]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a3088[Jakarta EJB 4.0 Spec - §18.3 Programmatic Timers (TimerService)]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a3185[Jakarta EJB 4.0 Spec - §18.4 Timer Persistence]****

EJB allows `@Schedule` methods with `Timer` parameter.
Spring `@Scheduled` requires parameterless methods.
If the timer context is used in the method body, direct migration to `@Scheduled` is not possible; the target mapping must be done via TaskScheduler or a persistent scheduling component.
The EJB attribute `persistent` is `true` by default.
Spring `@Scheduled` is not persistent, so persistence must be implemented explicitly if it is technically required.
=== @Schedule -> @Scheduled
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Singleton;
import javax.ejb.Startup;
import javax.ejb.Schedule;
import javax.ejb.Schedules;

@Singleton
@Startup
public class ComplianceTasks {

    @Schedule(hour = "2", minute = "0", second = "0", persistent = false)
    public void dailyCleanup() {
    }

    @Schedule(minute = "*/5", hour = "*", persistent = false)
    public void periodicCheck() {
    }

    @Schedule(dayOfWeek = "Mon-Fri", hour = "9", minute = "0", persistent = false)
    public void workdayReport() {
    }

    @Schedules({
        @Schedule(dayOfMonth = "1", hour = "0"),
        @Schedule(dayOfMonth = "15", hour = "0")
    })
    public void bimonthlyTask() {
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class ComplianceTasks {

    @Scheduled(cron = "0 0 2 * * *")
    public void dailyCleanup() {
    }

    @Scheduled(fixedRate = 300000)
    public void periodicCheck() {
    }

    @Scheduled(cron = "0 0 9 * * MON-FRI")
    public void workdayReport() {
    }

    @Scheduled(cron = "0 0 0 1 * *")
    public void monthStart() {
        bimonthlyTask();
    }

    @Scheduled(cron = "0 0 0 15 * *")
    public void monthMiddle() {
        bimonthlyTask();
    }

    private void bimonthlyTask() {
    }
}
----

[NOTE]====
Spring Cron Format: `Second Minute Hour Day Month Weekday` (6 fields).
EJB `@Schedule` supports additional attributes (e.g. `year`) that are not available in Spring.
====

The EJB specification defines default values ​​for `@Schedule`: `second`, `minute` and `hour` default to `"0"`, `dayOfMonth`, `month`, `dayOfWeek` and `year` default to `"*"`.
If `dayOfMonth` and `dayOfWeek` both have non-wildcard values, OR semantics apply.
Additionally, a `timezone` can be specified; the default is the container time zone.
These details must be taken into account when switching to Spring Cron, as Spring does not have a `year` specification and a different time zone must be explicitly configured.
=== Program-controlled timers (TimerService)
EJB provides an API called `TimerService` for creating timers programmatically. These timers are container managed and can be persistent. In Spring, dynamic jobs are typically implemented with `TaskScheduler` or through a separate scheduling component. Persistence must be solved explicitly, for example through a database table and a restart mechanism.
`TimerService` is often used to create dynamic schedules from specialist data, for example for deadlines or follow-ups. These timers are transactionally integrated into EJB and can be restored after server restarts.
EJB timers supply technical context data to @Timeout methods via `Timer.getInfo()`. This context information must be explicitly stored in Spring and passed to the task to be executed.
`@Timeout` methods are allowed to accept a `Timer` parameter in EJB. There is no direct counterpart for such callback signatures in Spring, so the timer context must be provided using its own scheduling structures.
The EJB API additionally provides functions such as `getNextTimeout()`, `getTimeRemaining()`, `getSchedule()` and `cancel()`. This information is only available in Spring through its own scheduling infrastructure, such as `ScheduledFuture` or a job scheduler with context access.
Persistent timers, cluster behavior and redelivery are defined in EJB, not in Spring. For migration, a decision must be made as to whether persistence is required (e.g. Quartz) or whether in-memory scheduling is sufficient.
=== Decision logic
[cols="1,2"]|===
| Requirement | Suitable approach

| Simple cron logic without `Timer` usage
| `@Scheduled`

| Access to timer context in method body
| `TaskScheduler` or Quartz

| Persistent execution
| Quartz

| Cluster coordination without persistence
| Locking mechanism + `@Scheduled` (e.g., ShedLock)

| Full EJB timer feature set
| Quartz
|===

=== Project control via project.yaml
The timer migration strategy can be configured via `project.yaml` in the project root. The selection of the
Timer recipes should be done consistently with this strategy.
[source,yaml]----
migration:
  timer:
    strategy: quartz   # scheduled | taskscheduler | quartz
    cluster: none          # none | quartz-jdbc | shedlock
----

For `cluster: quartz-jdbc`, `strategy: quartz` is required. `cluster: shedlock` is not compatible with
`strategy: quartz` and requires `scheduled` or `taskscheduler`.
=== Automated migration
==== Available Recipes
[cols="1,2,1"]|===
| Recipe | Description | Strategy

| `MigrateScheduleToScheduled`
| @Schedule → @Scheduled (safe cases)
| scheduled

| `MigrateScheduleToTaskScheduler`
| @Schedule → TaskScheduler (with Timer parameter)
| taskscheduler

| `MigrateScheduleToQuartz`
| @Schedule → Quartz Job
| quartz

| `MigrateEjbProgrammaticTimers`
| TimerService.create* → TaskScheduler
| taskscheduler

| `MigrateTimerServiceToQuartz`
| TimerService.create* → Quartz Scheduler
| quartz

| `MigrateTransactionalTimerCreation`
| TimerService.create* → transactional creation via event (after-commit)
| taskscheduler/quartz

| `MapEjbAnnotationsToMarkers`
| Fallback: @Schedule → @EjbSchedule (No-Op)
| (all)

| `MarkEjbTimerServiceForReview`
| Marks TimerService/@Timeout for review (NeedsReview + profile)
| review

| `MigrateTimerApiToStubs`
| Replaces jakarta/javax.ejb timer types with stub types for compile stability
| compile
|===

The default chain `com.github.rewrite.ejb.MigrateEjbToSpring` currently enables `MigrateScheduleToScheduled` for timers,
`MigrateEjbProgrammaticTimers`, `MapEjbAnnotationsToMarkers`, `MarkEjbTimerServiceForReview` and
`MigrateTimerApiToStubs`. Quartz and TaskScheduler variants are activated as opt-in recipes when included in the
Recipe list can be explicitly selected.
The selection of the timer strategy is therefore a pipeline decision: `scheduled` uses the standard chain,
`taskscheduler` uses `MigrateScheduleToTaskScheduler` and `MigrateEjbProgrammaticTimers` as well as the markers for
non-migrated cases, `quartz` uses `MigrateScheduleToQuartz` and `MigrateTimerServiceToQuartz` included
AutoConfiguration for Quartz. The strategy stored in `project.yaml` should match the one actually executed
Recipe combination match.
=== Limitations of automatic timer migration
The following limitations are intended as a final summary of the
understand automated timer migration. They reflect the current one
implementation status and must be used when evaluating migration results
be taken into account.
==== Principle: Default persistence
In EJB, `persistent = true` is the default for all timer constructs:
`@Schedule` without `persistent`, `TimerService.createTimer(delay, info)` without `TimerConfig`
and `new TimerConfig()` without parameters. Done without explicit `persistent = false`
no automatic migration to `@Scheduled` or TaskScheduler.
==== @Schedule and @Schedules
- `year` attribute: Spring Cron does not have a year field. @Schedule with `year` will not
  migrated automatically.
- `persistent = true` (explicit or default): requires persistence; automatic
  Migration to `@Scheduled` is impossible.
- Timer parameters in the method signature: `@Scheduled` is parameterless.
- Non-literal attributes (constants, variables): values are not present at compile time
  safely solvable.
- `@Schedules` with multiple entries: simple cases are migrated, complex ones
  Combinations (e.g. mixed persistent values) do not.
==== TimerService API
- `createTimer`/`createSingleActionTimer`/`createIntervalTimer` are only used in the
  safe subset automated (TimerConfig with `persistent=false` as literal,
  exactly one parameterless `@Timeout` method, return value is ignored).
- Dynamic `TimerConfig` configuration (`setPersistent`, `setInfo`) is not
  automatically resolvable.
- `createCalendarTimer` is only used for a limited subset of the
  `ScheduleExpression` attributes automated. Special values like `Last`, `1st/2nd`
  or `start/end` fall out of the automation.
- `TimerHandle` and `Timer.getSchedule()` can only be automated if a
  Project-specific Quartz strategy is used and no handle escapes.
==== Migration requirements
The automatic migration to `@Scheduled` occurs **only if all** of the following conditions are met:
[cols="1,2"]|===
| Condition | Verification

| `persistent = false`
| Must be explicitly set (EJB default is `true`)

| No Timer parameter
| Method must not have a `Timer` parameter

| No non-literal values
| All attributes must be string literals (no constants)

| No `year` attribute
| `year` must not be set (Spring cron has no year field)
|===

==== Marker fallback
If any of the conditions are not met, the `@Schedule` annotation will **not** be migrated.
Instead, the following recipe `MapEjbAnnotationsToMarkers` converts the annotation to `@EjbSchedule`:
[source, java]----
// Before - persistent=true (default) or Timer parameter
@Schedule(second = "*/6", minute = "*", hour = "*")
public void timer(Timer timer) {
    timer.getInfo();
}

// After - No-Op marker preserves all attributes
@EjbSchedule(second = "*/6", minute = "*", hour = "*", persistent = true)
public void timer(Timer timer) {
    timer.getInfo();
}
----

The `@EjbSchedule` marker is a no-op annotation with no runtime behavior.
It documents the original EJB semantics and enables later manual migration to TaskScheduler or Quartz.
[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateScheduling`
| Description | Combines `MigrateScheduleToScheduled`, `MigrateEjbProgrammaticTimers` and `AddEnableJmsAndScheduling`.
| Configuration | none
|===

---
