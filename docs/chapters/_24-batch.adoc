== Jakarta Batch

Jakarta Batch (JSR 352) definiert ein Job-Modell mit Schritten, Checkpoints und einem standardisierten Repository. Spring Batch bietet ein eigenes, stärker konfigurierbares Modell. In diesem Projekt werden Jakarta‑Batch‑Klassen durch Marker‑Rezepte identifiziert und mit `@NeedsReview` gekennzeichnet.

.Spezifikationsreferenzen
****
* https://jakarta.ee/specifications/batch/2.1/jakarta-batch-spec-2.1.html[Jakarta Batch 2.1 Spec]
* https://jakarta.ee/specifications/batch/2.1/jakarta-batch-spec-2.1.html#job-specification-language[Jakarta Batch 2.1 - §8 Job Specification Language]
* https://jakarta.ee/specifications/batch/2.1/jakarta-batch-spec-2.1.html#chunk-processing[Jakarta Batch 2.1 - §9 Chunk Processing]
* https://docs.spring.io/spring-batch/reference/[Spring Batch Reference]
****

=== Unterschiede in der Modellierung

Jakarta Batch nutzt `@BatchProperty`, `JobOperator` und XML-basierte Job-Definitionen. Spring Batch modelliert Jobs als Java-Konfiguration oder über eigene DSLs. Checkpoint-Mechanismen, Restart-Logik und Parameterübergabe unterscheiden sich in Details.

Spring Batch arbeitet mit einem Job‑Repository, das den Ausführungszustand persistiert. Die Entscheidung über Datenbank‑Schema, Restart‑Semantik und Chunk‑Größen ist Teil der Migration, da das Laufzeitverhalten ohne diese Einstellungen nicht reproduzierbar ist.

=== Migrationskontext

Die Migration von Jakarta Batch zu Spring Batch umfasst die Analyse bestehender Job-Definitionen, die Modellierung der Schritte als Spring-Batch-Konfigurationen sowie die Definition von Repository- und Restart-Strategien. Die fachliche Bedeutung der einzelnen Schritte und ihre Checkpoint-Logik müssen verstanden werden, bevor eine Zielkonfiguration erstellt wird.

=== Automatisierung im Projekt

Beide Recipes sind Teil der Hauptpipeline `MigrateEjbToSpring` und laufen automatisch:

* `com.github.rewrite.ejb.MarkJakartaBatchForMigration` markiert Jakarta‑Batch‑Klassen mit `@NeedsReview`.
* `com.github.rewrite.ejb.GenerateSpringBatchConfigFromJsl` erzeugt aus JSL-Job-XML eine Spring‑Batch‑Konfigurationsklasse
  `BatchJobsConfiguration` mit `Job`- und `Step`‑Skeletons.

Keine zusätzliche Konfiguration in `project.yaml` erforderlich.

Der Stub-Generator ist bewusst konservativ. Er erzeugt eine `@NeedsReview`‑Markierung auf Konfigurationsklassebene
(`NeedsReview.Category.MANUAL_MIGRATION`) und setzt zusätzliche TODO‑Hinweise, wenn die JSL‑Definition nicht eindeutig
in eine lineare `JobBuilder`‑Kette überführt werden kann.

==== JSL-Parsing und Ausgabeumfang

Der Generator verarbeitet Job‑XML aus `src/main/resources` (typisch `META-INF/batch-jobs`) und erzeugt `Job`/`Step`‑Beans
mit minimalem Wiring:

* `chunk`‑Steps werden als `StepBuilder(...).<Object, Object>chunk(...)` erzeugt.
* `batchlet`‑Steps werden als `tasklet(...)` erzeugt.
* `reader`/`processor`/`writer`‑Referenzen werden als `@Qualifier`‑Parameter übernommen.

Fehlende Referenzen führen zu expliziten TODO‑Kommentaren und vermeiden stillschweigende Fehldefinitionen.

==== Flows und Transitionen

JSL‑Transitionen (`next`‑Attribute oder `<next>`, `<stop>`, `<end>`, `<fail>`) sowie
`<split>`, `<flow>`, `<decision>` werden als „komplex“ markiert. In diesen Fällen wird keine automatische
`JobBuilder`‑Chaining‑Logik erzeugt; stattdessen wird ein TODO‑Hinweis im generierten Job eingefügt.

Die Migration solcher Flows erfordert eine explizite Modellierung mit Spring Batch (Flow‑API, JobExecutionDecider,
Partitioning). Diese Schritte bleiben bewusst manuell.

=== Prüfpunkte für das Projekt

Vor der Migration müssen die vorhandenen Batch-Jobs erfasst werden:

[cols="1,3"]
|===
| Aspekt | Prüfung

| Job-Definitionen
| Welche JSL-Dateien existieren in `META-INF/batch-jobs/`?

| Step-Typen
| Welche Steps sind Chunk-basiert, welche Batchlet?

| Checkpoint-Strategie
| Welche `item-count` oder Custom-Checkpoint-Algorithmen werden verwendet?

| Job-Parameter
| Welche Parameter werden über `JobOperator.start()` übergeben?

| Restart-Semantik
| Werden Jobs nach Fehlern neu gestartet (Checkpoint-Recovery)?

| Partitioning
| Werden Steps partitioniert (`<partition>`)?
|===

=== Mapping Jakarta Batch → Spring Batch

[cols="1,2,2"]
|===
| Jakarta Batch | Spring Batch | Hinweis

| `@BatchProperty`
| `@Value("#{jobParameters['name']}")`
| SpEL-basierte Parameter-Injection

| `JobOperator`
| `JobLauncher`
| Unterschiedliche API

| JSL (XML)
| Java-Config oder XML
| Java-Config bevorzugt

| `ItemReader/Writer`
| `ItemReader<T>/ItemWriter<T>`
| Generics in Spring

| `@Named` CDI-Bean
| Spring `@Component`
| Bean-Discovery unterschiedlich
|===
