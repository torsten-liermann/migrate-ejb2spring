== Transactions
Transactions are a core part of the specification in EJB. Container-Managed Transactions (CMT) are the standard, and transaction semantics are controlled via `@TransactionAttribute` and optionally `@TransactionManagement`. Spring also offers declarative transactions, but the rules are not identical: rollback behavior, proxy limits and call paths must be consciously considered.
.Specification references***** https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a881[Jakarta EJB 4.0 Spec - Chapter 8: Transaction Management]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a2065[Jakarta EJB 4.0 Spec - ยง13.2 Transaction Attributes]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a1984[Jakarta EJB 4.0 Spec - ยง13.1 Bean-Managed vs Container-Managed]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#a2200[Jakarta EJB 4.0 Spec - ยง13.3.1 Rollback Rules]****

=== @TransactionAttribute -> @Transactional
The basic propagation rules can be mapped, but the semantics of the exceptions are different (by default, Spring only rolls back for unchecked exceptions). This must be checked explicitly in the transaction chapter.
.TransactionAttributeType Mapping
[cols="2,2,1"]|===
| EJB TransactionAttributeType | Spring Propagation | Standard

| `REQUIRED`
| `Propagation.REQUIRED`
| icon:check[role=green] (Default)

| `REQUIRES_NEW`
| `Propagation.REQUIRES_NEW`
|

| `MANDATORY`
| `Propagation.MANDATORY`
|

| `NOT_SUPPORTED`
| `Propagation.NOT_SUPPORTED`
|

| `SUPPORTS`
| `Propagation.SUPPORTS`
|

| `NEVER`
| `Propagation.NEVER`
|
|===

.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;

@Stateless
public class AccountService {

    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public void transfer(AccountId fromId, AccountId toId, Money amount) {
    }

    @TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
    public void auditLog(String action, String details) {
    }

    @TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
    public AccountBalance getBalance(AccountId accountId) {
    }
}
----

In EJB, `REQUIRED` is the default value when no transaction annotation is set. Deployment descriptors can supplement or override transaction attributes; These overrides must be taken into account during the migration.
.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.annotation.Propagation;

@Service
@Transactional
public class AccountService {

    public void transfer(AccountId fromId, AccountId toId, Money amount) {
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void auditLog(String action, String details) {
    }

    @Transactional(propagation = Propagation.NOT_SUPPORTED, readOnly = true)
    public AccountBalance getBalance(AccountId accountId) {
    }
}
----

In Spring, `Propagation.REQUIRED` is the default behavior. Deviations such as `REQUIRES_NEW` or `NOT_SUPPORTED` must be specified explicitly.
[NOTE]====
Rollback rules differ: EJB rolls back on system exceptions, while Spring by default rolls back only on unchecked exceptions. Migrations with checked exceptions require explicit `rollbackFor` or `@Transactional` configuration.
====

=== Remove @TransactionManagement
EJB differentiates between container-managed (CMT) and bean-managed transactions (BMT). In Spring, declarative transaction is the default; Programmatic transactions are possible, but rarely necessary.
.Example: BEFORE (EJB)
[source, java]----
import javax.ejb.Stateless;
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.annotation.Resource;
import javax.transaction.UserTransaction;

@Stateless
@TransactionManagement(TransactionManagementType.CONTAINER)
public class OrderService {
}

@Stateless
@TransactionManagement(TransactionManagementType.BEAN)
public class SettlementService {

    @Resource
    private UserTransaction userTransaction;

    public void settle(InvoiceId invoiceId) throws Exception {
        userTransaction.begin();
        try {
            userTransaction.commit();
        } catch (Exception e) {
            userTransaction.rollback();
            throw e;
        }
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]----
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;

@Service
@Transactional
public class OrderService {
}

@Service
public class SettlementService {

    private final PlatformTransactionManager txManager;

    public SettlementService(PlatformTransactionManager txManager) {
        this.txManager = txManager;
    }

    public void settle(InvoiceId invoiceId) {
        TransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = txManager.getTransaction(def);
        try {
            txManager.commit(status);
        } catch (Exception e) {
            txManager.rollback(status);
            throw e;
        }
    }
}
----

In EJB, BMT may only be used where no container-managed transactions are active. When migrating, it is therefore important to check whether `UserTransaction` logic overlaps with `@Transactional` boundaries. In Spring, programmatic transactions are explicit and independent of @Transactional, but require clear accountability in the service design.
[CAUTION]====
Transactions in Spring apply only via proxies. Internal method calls within the same class bypass the proxy and do not start a transaction. This differs from EJB and must be checked explicitly during migration.
====

=== Automated migration
[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateTransactionAttribute`
| Description | Transforms `@TransactionAttribute` to `@Transactional` with appropriate propagation mapping.
| Configuration | none
|===

[cols="1.3"]|===
| Name | `de.example.rewrite.ejb.MigrateTransactions`
| Description | Combines all transaction recipes.
| Configuration | no
|===

---
