== Concurrency
EJB provides a declarative model for concurrency with `@Lock`, `@AccessTimeout` and `@ConcurrencyManagement`, especially for `@Singleton` beans. Spring does not offer a direct counterpart for this. This means that the migration must explicitly decide which synchronization strategy is required and how it will be technically implemented.
.Specification references
****
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#singleton-session-bean-concurrency[Jakarta EJB 4.0 Spec - ยง4.8 Singleton Session Bean Concurrency]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#lock[Jakarta EJB 4.0 Spec - ยง4.8.5 @Lock]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#access-timeout[Jakarta EJB 4.0 Spec - ยง4.8.6 @AccessTimeout]
* https://jakarta.ee/specifications/enterprise-beans/4.0/jakarta-enterprise-beans-spec-core-4.0.html#concurrency-management[Jakarta EJB 4.0 Spec - ยง4.8.7 @ConcurrencyManagement]
****

=== Singleton beans and locks
In EJB, a singleton bean is protected from parallel access problems by the container. This is done via `@Lock(READ)` and `@Lock(WRITE)` as well as optional timeouts. In Spring, a `@Service` singleton is a normal Java instance; Synchronization must be implemented explicitly. Methods that were protected by locks in EJB require a specific synchronization strategy in Spring.
In the specification, `@Lock(WRITE)` is considered the default if no explicit lock annotation is set. `@AccessTimeout` defines the maximum waiting time for a lock; a value of `-1` means waiting indefinitely. On timeout the container throws `ConcurrentAccessTimeoutException`.
.Example: BEFORE (EJB)
[source, java]
----
import javax.ejb.Singleton;
import javax.ejb.Lock;
import javax.ejb.LockType;
import javax.ejb.AccessTimeout;
import java.util.concurrent.TimeUnit;

@Singleton
public class ReferenceDataCache {

    @Lock(LockType.READ)
    public ReferenceData lookup(String code) {
        return cache.get(code);
    }

    @Lock(LockType.WRITE)
    @AccessTimeout(value = 5, unit = TimeUnit.SECONDS)
    public void refresh() {
        reload();
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.stereotype.Service;

@Service
public class ReferenceDataCache {

    public synchronized ReferenceData lookup(String code) {
        return cache.get(code);
    }

    public synchronized void refresh() {
        reload();
    }
}
----

The choice of synchronization depends on the data model. For high parallelism a `ReadWriteLock` can be useful, for asynchronous updating a `ScheduledExecutorService` or a `TaskScheduler` can be useful. A blanket removal of `@Lock` without replacement leads to functional and data consistency problems.
=== Automatic migration
The migration replaces `@Lock` annotations with `synchronized` modifiers and adds a `@NeedsReview` annotation indicating semantic simplification. With `@Lock(READ)` the parallel reading option is lost.
For high read throughput scenarios, the @NeedsReview annotation recommends upgrading to ReadWriteLock:
.Recommended ReadWriteLock upgrade
[source, java]
----
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import org.springframework.stereotype.Service;

@Service
public class ReferenceDataCache {
    private final ReadWriteLock lock = new ReentrantReadWriteLock();

    public ReferenceData lookup(String code) {
        lock.readLock().lock();
        try {
            return cache.get(code);
        } finally {
            lock.readLock().unlock();
        }
    }

    public void refresh() {
        lock.writeLock().lock();
        try {
            reload();
        } finally {
            lock.writeLock().unlock();
        }
    }
}
----

NOTE: `@AccessTimeout` is detected during migration but is not implemented automatically. For timeout semantics, `tryLock(timeout, TimeUnit)` needs to be implemented manually.
=== Bean-Managed Concurrency
`@ConcurrencyManagement(BEAN)` completely delegates synchronization to the implementation. In Spring this is the normal case: the bean itself is responsible for thread safety. During the migration, it should be documented which synchronization logic already exists and whether it is still sufficient.
