== CDI (Contexts and Dependency Injection)

CDI ist in Jakarta EE das zentrale Modell für Dependency Injection, Scopes und Eventing. Spring bietet eine ähnliche, aber nicht identische DI-Infrastruktur. Eine Migration muss daher Scopes, Producer, Qualifier und Events gezielt abbilden.

=== Scopes und Lebensdauer

CDI-Scopes wie `@ApplicationScoped`, `@RequestScoped` und `@SessionScoped` definieren die Lebensdauer der Bean. In Spring gibt es analoge Scopes, allerdings ist deren Nutzung stark vom Web-Stack abhängig. Für rein technische Beans wird in Spring häufig der Default-Scope (Singleton) verwendet. Scopes sollten daher nur dort übernommen werden, wo fachliche oder technische Lebensdauer erforderlich ist.

=== Producer und Qualifier

CDI-Producer (`@Produces`) liefern Beans, die über Qualifier auswählbar sind. In Spring wird dies in der Regel über `@Bean`-Methoden und `@Qualifier` umgesetzt. Qualifier können jedoch in CDI deutlich komplexer sein, etwa mit Annotation-Attributen. In solchen Fällen muss geprüft werden, ob Spring-Qualifier ausreichend sind oder ob eine explizite Bean-Registrierung pro Variante nötig ist.

Producer‑Methoden mit `InjectionPoint`‑Auswertung sind in CDI verbreitet, etwa um je nach Injektionsstelle unterschiedliche Instanzen zu erzeugen. Spring bietet hierfür kein direktes Pendant. Solche Fälle müssen in der Migration über explizite Fabriken, `FactoryBean`‑Implementierungen oder separate Bean‑Definitionen modelliert werden.

CDI‑`@Alternative` und `@Specializes` sind deklarative Mechanismen zur Auswahl von Implementierungen. In Spring werden vergleichbare Entscheidungen über Profile, Qualifier oder Primary‑Beans abgebildet. Die Auswahlregeln sind nicht identisch und müssen für jede Alternative geprüft werden.

=== CDI Events

`Event<T>` und `@Observes` bilden ein asynchrones oder synchrones Eventing-Modell ab. Spring bietet mit `ApplicationEventPublisher` und `@EventListener` eine funktional ähnliche Lösung, jedoch mit anderen Semantiken für generische Typen, Ordering und Threading. Die Migration sollte insbesondere prüfen, ob Events in EJB asynchron oder transaktional gebunden sind.

CDI kennt `@ObservesAsync` für asynchrone Event‑Verarbeitung und eine definierte Zustellreihenfolge innerhalb der CDI‑Infrastruktur. Spring unterscheidet zwischen synchronen Listenern und explizit asynchronen Listenern (`@Async`), wobei die Ausführung vom Task‑Executor abhängt. Diese Unterschiede müssen bei der Migration berücksichtigt werden, wenn Event‑Reihenfolgen oder Transaktionsgrenzen fachlich relevant sind.

=== Beispiel

.Beispiel: VORHER (CDI)
[source,java]
----
import javax.enterprise.event.Event;
import javax.inject.Inject;
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class CargoEventPublisher {

    @Inject
    private Event<CargoHandledEvent> handledEvent;

    public void publish(CargoHandledEvent event) {
        handledEvent.fire(event);
    }
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

@Component
public class CargoEventPublisher {

    private final ApplicationEventPublisher publisher;

    public CargoEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void publish(CargoHandledEvent event) {
        publisher.publishEvent(event);
    }
}
----
