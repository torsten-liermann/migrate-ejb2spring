== CDI (Contexts and Dependency Injection)
CDI is the central model for dependency injection, scopes and eventing in Jakarta EE. Spring offers a similar, but not identical, DI infrastructure. A migration must therefore specifically map scopes, producers, qualifiers and events.
=== Scopes and lifespan
CDI scopes such as `@ApplicationScoped`, `@RequestScoped` and `@SessionScoped` define the lifetime of the bean. There are analog scopes in Spring, but their use depends heavily on the web stack. The default scope (singleton) is often used in Spring for purely technical beans. Scopes should therefore only be adopted where professional or technical durability is required.
=== Producer and Qualifier
CDI producers (`@Produces`) deliver beans that can be selected via qualifiers. In Spring this is usually implemented via `@Bean` methods and `@Qualifier`. However, qualifiers in CDI can be much more complex, for example with annotation attributes. In such cases, it must be checked whether Spring qualifiers are sufficient or whether an explicit bean registration per variant is necessary.
Producer methods with “InjectionPoint” evaluation are common in CDI, for example to create different instances depending on the injection site. Spring does not offer a direct counterpart for this. Such cases must be modeled in the migration using explicit factories, `FactoryBean` implementations or separate bean definitions.
CDI‑`@Alternative` and `@Specializes` are declarative mechanisms for selecting implementations. In Spring, comparable decisions are made using profiles, qualifiers or primary beans. The selection rules are not identical and must be checked for each alternative.
=== CDI events
`Event<T>` and `@Observes` represent an asynchronous or synchronous eventing model. Spring offers a functionally similar solution with `ApplicationEventPublisher` and `@EventListener`, but with different semantics for generic types, ordering and threading. The migration should in particular check whether events in EJB are asynchronously or transactionally bound.
CDI knows `@ObservesAsync` for asynchronous event processing and a defined delivery order within the CDI infrastructure. Spring differentiates between synchronous listeners and explicitly asynchronous listeners (`@Async`), where execution depends on the task executor. These differences must be taken into account during migration if event sequences or transaction boundaries are technically relevant.
=== Example
.Example: BEFORE (CDI)
[source, java]
----
import javax.enterprise.event.Event;
import javax.inject.Inject;
import javax.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class CargoEventPublisher {

    @Inject
    private Event<CargoHandledEvent> handledEvent;

    public void publish(CargoHandledEvent event) {
        handledEvent.fire(event);
    }
}
----

.Example: AFTER (Spring Boot)
[source, java]
----
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

@Component
public class CargoEventPublisher {

    private final ApplicationEventPublisher publisher;

    public CargoEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void publish(CargoHandledEvent event) {
        publisher.publishEvent(event);
    }
}
----
