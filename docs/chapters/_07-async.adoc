== Asynchrone Verarbeitung

EJB `@Asynchronous` delegiert die Ausführung an den Container. Der Container verwaltet Threads, Security Context und (je nach Konfiguration) Transaktionskontext. In Spring übernimmt `@Async` eine ähnliche Rolle, arbeitet aber über Proxies und einen `TaskExecutor`. Selbstaufrufe innerhalb derselben Klasse bleiben synchron, und Kontextweitergabe (Security, MDC, Transactions) ist explizit zu prüfen.

=== @Asynchronous -> @Async

.Beispiel: VORHER (EJB)
[source,java]
----
import javax.ejb.Stateless;
import javax.ejb.Asynchronous;
import java.util.concurrent.Future;

@Stateless
public class NotificationService {

    @Asynchronous
    public void sendShipmentNotice(ShipmentId id) {
    }

    @Asynchronous
    public Future<DispatchResult> dispatch(DispatchCommand command) {
        DispatchResult result = executeDispatch(command);
        return new AsyncResult<>(result);
    }
}
----

.Beispiel: NACHHER (Spring Boot)
[source,java]
----
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.stereotype.Service;
import java.util.concurrent.CompletableFuture;

@Service
public class NotificationService {

    @Async
    public void sendShipmentNotice(ShipmentId id) {
    }

    @Async
    public CompletableFuture<DispatchResult> dispatch(DispatchCommand command) {
        DispatchResult result = executeDispatch(command);
        return CompletableFuture.completedFuture(result);
    }
}
----

.Beispiel: Konfiguration (Spring Boot)
[source,java]
----
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class AsyncConfiguration {
}
----

[WARNING]
====
`@Async` wirkt nur über Spring-Proxies. Aufrufe innerhalb derselben Klasse bleiben synchron. ThreadLocals (Security Context, MDC) müssen explizit propagiert werden.
====

=== Custom Executor

In EJB wird der Threadpool durch den Container bereitgestellt. In Spring sollte ein expliziter `TaskExecutor` konfiguriert werden, wenn Fachprozesse getrennte Ressourcen benötigen.

.Beispiel: Executor-Konfiguration
[source,java]
----
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.context.annotation.Bean;

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "dispatchExecutor")
    public ThreadPoolTaskExecutor dispatchExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("dispatch-");
        executor.initialize();
        return executor;
    }
}
----

.Beispiel: Nutzung des Executors
[source,java]
----
@Service
public class DispatchService {

    @Async("dispatchExecutor")
    public CompletableFuture<DispatchResult> dispatch(DispatchCommand command) {
    }
}
----

=== Automatisierte Migration

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigrateAsynchronousToAsync`
| Beschreibung | Transformiert `@Asynchronous` zu `@Async`.
| Konfiguration | keine
|===

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigrateAsyncResultToCompletableFuture`
| Beschreibung | Transformiert `AsyncResult<T>` zu `CompletableFuture<T>`.
| Konfiguration | keine
|===

[cols="1,3"]
|===
| Name | `de.example.rewrite.ejb.MigrateAsync`
| Beschreibung | Kombiniert `MigrateAsynchronousToAsync`, `MigrateAsyncResultToCompletableFuture` und `AddEnableJmsAndScheduling`.
| Konfiguration | keine
|===

---
