package com.github.rewrite.ejb;

import com.github.rewrite.ejb.config.ProjectConfiguration;
import com.github.rewrite.ejb.config.ProjectConfigurationLoader;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jspecify.annotations.Nullable;
import org.openrewrite.*;
import org.openrewrite.java.AnnotationMatcher;
import org.openrewrite.java.JavaIsoVisitor;
import org.openrewrite.java.tree.*;
import org.openrewrite.text.PlainText;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Generates @HttpExchange client interfaces for @Remote EJB interfaces.
 * <p>
 * This recipe generates:
 * <ul>
 *   <li>{Interface}Client with @HttpExchange/@PostExchange annotations</li>
 *   <li>{Interface}ClientConfig @Configuration class with RestClient setup</li>
 * </ul>
 * <p>
 * The generated client can be used by remote callers to invoke the
 * REST endpoints generated by {@link MigrateRemoteToRest}.
 *
 * @see MigrateRemoteToRest
 * @see ProjectConfiguration.RemoteStrategy#REST
 */
@Value
@EqualsAndHashCode(callSuper = false)
public class GenerateHttpExchangeClient extends ScanningRecipe<GenerateHttpExchangeClient.Accumulator> {

    @Option(displayName = "Target package suffix",
            description = "Suffix appended to the remote type package for generated clients.",
            example = "client",
            required = false)
    @Nullable
    String targetPackageSuffix;

    public GenerateHttpExchangeClient() {
        this.targetPackageSuffix = null;
    }

    public GenerateHttpExchangeClient(@Nullable String targetPackageSuffix) {
        this.targetPackageSuffix = targetPackageSuffix;
    }

    @Override
    public String getDisplayName() {
        return "Generate @HttpExchange client for @Remote interface";
    }

    @Override
    public String getDescription() {
        return "Generates @HttpExchange client interfaces and configuration for @Remote EJB interfaces. " +
               "Works with REST controllers generated by MigrateRemoteToRest.";
    }

    static class Accumulator {
        Map<String, RemoteInterfaceInfo> remoteInterfaces = new LinkedHashMap<>();
        Set<Path> existingSourcePaths = new HashSet<>();
    }

    static class RemoteInterfaceInfo {
        final String fqn;
        final String packageName;
        final String simpleName;
        final String mainSourceRoot;
        final List<MethodInfo> methods;

        RemoteInterfaceInfo(String fqn, String packageName, String simpleName,
                           String mainSourceRoot, List<MethodInfo> methods) {
            this.fqn = fqn;
            this.packageName = packageName;
            this.simpleName = simpleName;
            this.mainSourceRoot = mainSourceRoot;
            this.methods = methods;
        }
    }

    static class MethodInfo {
        final String name;
        final String returnType;
        final String returnTypeSimple;
        final List<ParamInfo> params;
        final boolean needsDto;
        final String dtoName; // Unique DTO name for overloaded methods
        final int overloadIndex;

        MethodInfo(String name, String returnType, String returnTypeSimple, List<ParamInfo> params,
                   String dtoName, int overloadIndex) {
            this.name = name;
            this.returnType = returnType;
            this.returnTypeSimple = returnTypeSimple;
            this.params = params;
            this.dtoName = dtoName;
            this.overloadIndex = overloadIndex;
            this.needsDto = params.size() > 1 ||
                           (params.size() == 1 && isPrimitive(params.get(0).type));
        }

        private static boolean isPrimitive(String type) {
            return PRIMITIVE_TYPES.contains(type);
        }

        static final Set<String> PRIMITIVE_TYPES = Set.of(
            "int", "long", "short", "byte", "float", "double", "boolean", "char",
            "Integer", "Long", "Short", "Byte", "Float", "Double", "Boolean", "Character",
            "java.lang.Integer", "java.lang.Long", "java.lang.Short", "java.lang.Byte",
            "java.lang.Float", "java.lang.Double", "java.lang.Boolean", "java.lang.Character",
            "String", "java.lang.String"
        );
    }

    static class ParamInfo {
        final String type;        // FQN (e.g., "com.example.Foo" or "com.example.Foo[]" for varargs)
        final String typeSimple;  // Simple name (e.g., "Foo" or "Foo[]" for varargs)
        final String name;
        final boolean isVarargs;  // True if parameter was declared with varargs syntax

        ParamInfo(String type, String typeSimple, String name, boolean isVarargs) {
            this.type = type;
            this.typeSimple = typeSimple;
            this.name = name;
            this.isVarargs = isVarargs;
        }

        String getImportableFqn() {
            String t = type;
            if (t == null) {
                return null;
            }
            // Strip array suffix before processing
            if (t.endsWith("[]")) {
                t = t.substring(0, t.length() - 2);
            }
            if (t.startsWith("java.lang.") || !t.contains(".") || MethodInfo.PRIMITIVE_TYPES.contains(t)) {
                return null;
            }
            if (t.contains("<")) {
                return t.substring(0, t.indexOf('<'));
            }
            return t;
        }
    }

    /** Temporary holder for method extraction */
    private static class MethodData {
        final String name;
        final String returnType;
        final String returnTypeSimple;
        final List<ParamInfo> params;

        MethodData(String name, String returnType, String returnTypeSimple, List<ParamInfo> params) {
            this.name = name;
            this.returnType = returnType;
            this.returnTypeSimple = returnTypeSimple;
            this.params = params;
        }
    }

    private static final AnnotationMatcher REMOTE_JAVAX = new AnnotationMatcher("@javax.ejb.Remote");
    private static final AnnotationMatcher REMOTE_JAKARTA = new AnnotationMatcher("@jakarta.ejb.Remote");

    @Override
    public Accumulator getInitialValue(ExecutionContext ctx) {
        return new Accumulator();
    }

    @Override
    public TreeVisitor<?, ExecutionContext> getScanner(Accumulator acc) {
        return new TreeVisitor<Tree, ExecutionContext>() {
            @Override
            public Tree visit(Tree tree, ExecutionContext ctx) {
                if (tree instanceof PlainText) {
                    PlainText text = (PlainText) tree;
                    acc.existingSourcePaths.add(text.getSourcePath());
                    return text;
                }
                if (tree instanceof J.CompilationUnit) {
                    J.CompilationUnit cu = (J.CompilationUnit) tree;
                    scanCompilationUnit(cu, acc);
                    return cu;
                }
                return tree;
            }
        };
    }

    private void scanCompilationUnit(J.CompilationUnit cu, Accumulator acc) {
        if (cu.getSourcePath() != null) {
            acc.existingSourcePaths.add(cu.getSourcePath());
        }

        if (cu.getPackageDeclaration() == null || cu.getSourcePath() == null) {
            return;
        }

        String sourcePath = cu.getSourcePath().toString().replace('\\', '/');
        ProjectConfiguration config = ProjectConfigurationLoader.loadWithInheritance(extractProjectRoot(cu.getSourcePath()));
        if (!config.isMainSource(sourcePath)) {
            return;
        }
        String mainSourceRoot = extractMainSourceRoot(sourcePath, config);

        for (J.ClassDeclaration classDecl : cu.getClasses()) {
            if (classDecl.getType() == null) {
                continue;
            }

            if (hasRemoteAnnotation(classDecl) && isInterface(classDecl)) {
                String fqn = classDecl.getType().getFullyQualifiedName();
                if (!acc.remoteInterfaces.containsKey(fqn)) {
                    String packageName = cu.getPackageDeclaration().getPackageName();
                    List<MethodInfo> methods = extractMethods(classDecl);
                    acc.remoteInterfaces.put(fqn, new RemoteInterfaceInfo(
                            fqn, packageName, classDecl.getSimpleName(), mainSourceRoot, methods));
                }
            }
        }
    }

    private boolean hasRemoteAnnotation(J.ClassDeclaration classDecl) {
        for (J.Annotation ann : classDecl.getLeadingAnnotations()) {
            if (REMOTE_JAVAX.matches(ann) || REMOTE_JAKARTA.matches(ann)) {
                return true;
            }
        }
        return false;
    }

    private boolean isInterface(J.ClassDeclaration classDecl) {
        return classDecl.getKind() == J.ClassDeclaration.Kind.Type.Interface;
    }

    private List<MethodInfo> extractMethods(J.ClassDeclaration classDecl) {
        List<MethodInfo> methods = new ArrayList<>();
        if (classDecl.getBody() == null) {
            return methods;
        }

        // First pass: collect all method data
        List<MethodData> methodDataList = new ArrayList<>();
        for (Statement stmt : classDecl.getBody().getStatements()) {
            if (!(stmt instanceof J.MethodDeclaration)) {
                continue;
            }
            J.MethodDeclaration method = (J.MethodDeclaration) stmt;
            if (method.isConstructor() || isStatic(method)) {
                continue;
            }

            String returnType = resolveTypeName(method.getReturnTypeExpression());
            String returnTypeSimple = resolveSimpleTypeName(method.getReturnTypeExpression());
            List<ParamInfo> params = new ArrayList<>();

            for (Statement param : method.getParameters()) {
                if (!(param instanceof J.VariableDeclarations)) {
                    continue;
                }
                J.VariableDeclarations varDecls = (J.VariableDeclarations) param;
                String typeName = resolveTypeName(varDecls.getTypeExpression());
                String typeSimple = resolveSimpleTypeName(varDecls.getTypeExpression());
                boolean isVarargs = varDecls.getVarargs() != null;
                if (isVarargs) {
                    // Store as array syntax for DTOs (valid field type), not varargs syntax
                    typeName = typeName + "[]";
                    typeSimple = typeSimple + "[]";
                }
                for (J.VariableDeclarations.NamedVariable var : varDecls.getVariables()) {
                    params.add(new ParamInfo(typeName, typeSimple, var.getSimpleName(), isVarargs));
                }
            }

            methodDataList.add(new MethodData(method.getSimpleName(), returnType, returnTypeSimple, params));
        }

        // Second pass: count overloads and assign unique DTO names
        Map<String, Integer> methodCounts = new LinkedHashMap<>();
        for (MethodData md : methodDataList) {
            methodCounts.merge(md.name, 1, Integer::sum);
        }

        Map<String, Integer> methodIndexes = new LinkedHashMap<>();
        for (MethodData md : methodDataList) {
            int count = methodCounts.get(md.name);
            int index = methodIndexes.merge(md.name, 0, (old, v) -> old + 1);

            String dtoName;
            if (count == 1) {
                dtoName = capitalize(md.name) + "Request";
            } else {
                dtoName = capitalize(md.name) + (index + 1) + "Request";
            }

            methods.add(new MethodInfo(md.name, md.returnType, md.returnTypeSimple, md.params, dtoName, index));
        }

        return methods;
    }

    private boolean isStatic(J.MethodDeclaration method) {
        for (J.Modifier modifier : method.getModifiers()) {
            if (modifier.getType() == J.Modifier.Type.Static) {
                return true;
            }
        }
        return false;
    }

    @Override
    public Collection<? extends SourceFile> generate(Accumulator acc, ExecutionContext ctx) {
        if (acc.remoteInterfaces.isEmpty()) {
            return List.of();
        }

        String packageSuffix = targetPackageSuffix == null ? "client" : targetPackageSuffix.trim();
        List<SourceFile> generated = new ArrayList<>();

        for (RemoteInterfaceInfo info : acc.remoteInterfaces.values()) {
            String targetPackage = resolveTargetPackage(info.packageName, packageSuffix);
            String restPackage = resolveTargetPackage(info.packageName, "rest");

            // Track which DTOs come from rest package (need import)
            Set<String> dtosFromRestPackage = new LinkedHashSet<>();

            // Generate DTOs for methods that need them (if not already in rest package)
            for (MethodInfo method : info.methods) {
                if (method.needsDto) {
                    Path dtoPath = resolveTargetPath(info.mainSourceRoot, targetPackage, method.dtoName);
                    Path restDtoPath = resolveTargetPath(info.mainSourceRoot, restPackage, method.dtoName);

                    if (acc.existingSourcePaths.contains(restDtoPath)) {
                        // DTO exists in rest package - need to import it
                        dtosFromRestPackage.add(method.dtoName);
                    } else if (!acc.existingSourcePaths.contains(dtoPath)) {
                        // Generate DTO in client package
                        String dtoSource = generateDto(targetPackage, method.dtoName, method.params);
                        generated.add(PlainText.builder()
                                .sourcePath(dtoPath)
                                .text(dtoSource)
                                .build());
                        acc.existingSourcePaths.add(dtoPath);
                    }
                }
            }

            // Generate client interface
            String clientName = info.simpleName + "Client";
            Path clientPath = resolveTargetPath(info.mainSourceRoot, targetPackage, clientName);

            if (!acc.existingSourcePaths.contains(clientPath)) {
                Set<String> requiredImports = collectRequiredImports(info, targetPackage);
                // Add DTO imports from rest package
                for (String dtoName : dtosFromRestPackage) {
                    requiredImports.add(restPackage + "." + dtoName);
                }
                String clientSource = generateClientInterface(info, targetPackage, clientName, requiredImports);
                generated.add(PlainText.builder()
                        .sourcePath(clientPath)
                        .text(clientSource)
                        .build());
                acc.existingSourcePaths.add(clientPath);
            }

            // Generate config class
            String configName = info.simpleName + "ClientConfig";
            Path configPath = resolveTargetPath(info.mainSourceRoot, targetPackage, configName);

            if (!acc.existingSourcePaths.contains(configPath)) {
                String configSource = generateConfig(info, targetPackage, clientName, configName);
                generated.add(PlainText.builder()
                        .sourcePath(configPath)
                        .text(configSource)
                        .build());
            }
        }

        return generated;
    }

    /**
     * Collects FQNs that need to be imported for the generated client interface.
     */
    private Set<String> collectRequiredImports(RemoteInterfaceInfo info, String targetPackage) {
        Set<String> imports = new LinkedHashSet<>();
        for (MethodInfo method : info.methods) {
            // Return type
            String returnImport = extractImportableFqn(method.returnType);
            if (returnImport != null && !isInPackage(returnImport, targetPackage)) {
                imports.add(returnImport);
            }
            imports.addAll(extractGenericTypeImports(method.returnType, targetPackage));

            // Parameters (for non-DTO methods)
            if (!method.needsDto) {
                for (ParamInfo param : method.params) {
                    String paramImport = param.getImportableFqn();
                    if (paramImport != null && !isInPackage(paramImport, targetPackage)) {
                        imports.add(paramImport);
                    }
                    imports.addAll(extractGenericTypeImports(param.type, targetPackage));
                }
            }
        }
        return imports;
    }

    private String extractImportableFqn(String type) {
        if (type == null || "void".equals(type) || !type.contains(".")) {
            return null;
        }
        if (type.startsWith("java.lang.") && !type.substring("java.lang.".length()).contains(".")) {
            return null;
        }
        String rawType = type.contains("<") ? type.substring(0, type.indexOf('<')) : type;
        if (!rawType.contains(".")) {
            return null;
        }
        return rawType;
    }

    private Set<String> extractGenericTypeImports(String type, String targetPackage) {
        Set<String> imports = new LinkedHashSet<>();
        if (type == null || !type.contains("<")) {
            return imports;
        }
        int start = type.indexOf('<');
        int end = type.lastIndexOf('>');
        if (start >= 0 && end > start) {
            String inner = type.substring(start + 1, end);
            for (String arg : splitTypeArguments(inner)) {
                String trimmed = arg.trim();
                String fqn = extractImportableFqn(trimmed);
                if (fqn != null && !isInPackage(fqn, targetPackage)) {
                    imports.add(fqn);
                }
                imports.addAll(extractGenericTypeImports(trimmed, targetPackage));
            }
        }
        return imports;
    }

    private List<String> splitTypeArguments(String inner) {
        List<String> args = new ArrayList<>();
        int depth = 0;
        int start = 0;
        for (int i = 0; i < inner.length(); i++) {
            char c = inner.charAt(i);
            if (c == '<') depth++;
            else if (c == '>') depth--;
            else if (c == ',' && depth == 0) {
                args.add(inner.substring(start, i));
                start = i + 1;
            }
        }
        if (start < inner.length()) {
            args.add(inner.substring(start));
        }
        return args;
    }

    private boolean isInPackage(String fqn, String targetPackage) {
        if (fqn == null || targetPackage == null || targetPackage.isEmpty()) {
            return false;
        }
        int lastDot = fqn.lastIndexOf('.');
        if (lastDot < 0) {
            return targetPackage.isEmpty();
        }
        return fqn.substring(0, lastDot).equals(targetPackage);
    }

    private String generateClientInterface(RemoteInterfaceInfo info, String targetPackage,
                                           String clientName, Set<String> requiredImports) {
        StringBuilder sb = new StringBuilder();

        if (!targetPackage.isEmpty()) {
            sb.append("package ").append(targetPackage).append(";\n\n");
        }

        // Custom type imports (sorted)
        List<String> sortedImports = new ArrayList<>(requiredImports);
        Collections.sort(sortedImports);
        for (String imp : sortedImports) {
            sb.append("import ").append(imp).append(";\n");
        }

        // Check if any method needs @RequestBody (methods with parameters)
        boolean needsRequestBodyImport = info.methods.stream()
                .anyMatch(m -> m.needsDto || m.params.size() == 1);

        // Spring imports
        if (needsRequestBodyImport) {
            sb.append("import org.springframework.web.bind.annotation.RequestBody;\n");
        }
        sb.append("import org.springframework.web.service.annotation.HttpExchange;\n");
        sb.append("import org.springframework.web.service.annotation.PostExchange;\n\n");

        // Interface declaration
        sb.append("@HttpExchange(\"/api/").append(info.simpleName).append("\")\n");
        sb.append("public interface ").append(clientName).append(" {\n");

        // Build overload count map to detect which methods need path disambiguation
        Map<String, Long> overloadCounts = info.methods.stream()
                .collect(java.util.stream.Collectors.groupingBy(m -> m.name, java.util.stream.Collectors.counting()));

        // Methods
        for (MethodInfo method : info.methods) {
            sb.append("\n");
            // Add path suffix for overloaded methods (e.g., /search/1, /search/2)
            String pathSuffix = overloadCounts.get(method.name) > 1 ? "/" + (method.overloadIndex + 1) : "";
            sb.append("    @PostExchange(\"/").append(method.name).append(pathSuffix).append("\")\n");

            if (method.needsDto) {
                sb.append("    ").append(method.returnTypeSimple).append(" ")
                  .append(method.name).append("(@RequestBody ").append(method.dtoName).append(" request);\n");
            } else if (method.params.size() == 1) {
                ParamInfo param = method.params.get(0);
                sb.append("    ").append(method.returnTypeSimple).append(" ")
                  .append(method.name).append("(@RequestBody ").append(param.typeSimple)
                  .append(" ").append(param.name).append(");\n");
            } else {
                sb.append("    ").append(method.returnTypeSimple).append(" ")
                  .append(method.name).append("();\n");
            }
        }

        sb.append("}\n");
        return sb.toString();
    }

    private String generateConfig(RemoteInterfaceInfo info, String targetPackage,
                                  String clientName, String configName) {
        StringBuilder sb = new StringBuilder();

        if (!targetPackage.isEmpty()) {
            sb.append("package ").append(targetPackage).append(";\n\n");
        }

        // Imports
        sb.append("import org.springframework.beans.factory.annotation.Value;\n");
        sb.append("import org.springframework.context.annotation.Bean;\n");
        sb.append("import org.springframework.context.annotation.Configuration;\n");
        sb.append("import org.springframework.web.client.RestClient;\n");
        sb.append("import org.springframework.web.client.support.RestClientAdapter;\n");
        sb.append("import org.springframework.web.service.invoker.HttpServiceProxyFactory;\n\n");

        // Config class
        sb.append("@Configuration\n");
        sb.append("public class ").append(configName).append(" {\n\n");

        // Base URL field
        String propertyName = decapitalize(info.simpleName) + ".baseUrl";
        sb.append("    @Value(\"${").append(propertyName).append("}\")\n");
        sb.append("    private String baseUrl;\n\n");

        // Bean method
        sb.append("    @Bean\n");
        sb.append("    public ").append(clientName).append(" ").append(decapitalize(clientName)).append("() {\n");
        sb.append("        RestClient restClient = RestClient.builder()\n");
        sb.append("                .baseUrl(baseUrl)\n");
        sb.append("                .build();\n");
        sb.append("        HttpServiceProxyFactory factory = HttpServiceProxyFactory\n");
        sb.append("                .builderFor(RestClientAdapter.create(restClient))\n");
        sb.append("                .build();\n");
        sb.append("        return factory.createClient(").append(clientName).append(".class);\n");
        sb.append("    }\n");

        sb.append("}\n");
        return sb.toString();
    }

    private String generateDto(String targetPackage, String dtoName, List<ParamInfo> params) {
        StringBuilder sb = new StringBuilder();

        if (!targetPackage.isEmpty()) {
            sb.append("package ").append(targetPackage).append(";\n\n");
        }

        // Collect and emit imports for non-java.lang field types
        Set<String> dtoImports = new LinkedHashSet<>();
        for (ParamInfo param : params) {
            String fqn = param.getImportableFqn();
            if (fqn != null && !isInPackage(fqn, targetPackage)) {
                dtoImports.add(fqn);
            }
            dtoImports.addAll(extractGenericTypeImports(param.type, targetPackage));
        }
        if (!dtoImports.isEmpty()) {
            List<String> sortedImports = new ArrayList<>(dtoImports);
            Collections.sort(sortedImports);
            for (String imp : sortedImports) {
                sb.append("import ").append(imp).append(";\n");
            }
            sb.append("\n");
        }

        sb.append("public class ").append(dtoName).append(" {\n\n");

        // Fields
        for (ParamInfo param : params) {
            sb.append("    private ").append(param.typeSimple).append(" ").append(param.name).append(";\n");
        }

        // Default constructor
        sb.append("\n    public ").append(dtoName).append("() {\n    }\n");

        // All-args constructor
        sb.append("\n    public ").append(dtoName).append("(");
        for (int i = 0; i < params.size(); i++) {
            if (i > 0) sb.append(", ");
            ParamInfo param = params.get(i);
            sb.append(param.typeSimple).append(" ").append(param.name);
        }
        sb.append(") {\n");
        for (ParamInfo param : params) {
            sb.append("        this.").append(param.name).append(" = ").append(param.name).append(";\n");
        }
        sb.append("    }\n");

        // Getters and Setters
        for (ParamInfo param : params) {
            String capitalized = capitalize(param.name);
            sb.append("\n    public ").append(param.typeSimple).append(" get")
              .append(capitalized).append("() {\n");
            sb.append("        return ").append(param.name).append(";\n");
            sb.append("    }\n");
            sb.append("\n    public void set").append(capitalized).append("(")
              .append(param.typeSimple).append(" ").append(param.name).append(") {\n");
            sb.append("        this.").append(param.name).append(" = ").append(param.name).append(";\n");
            sb.append("    }\n");
        }

        sb.append("}\n");
        return sb.toString();
    }

    private String resolveTargetPackage(String basePackage, String suffix) {
        if (suffix == null || suffix.isBlank()) {
            return basePackage == null ? "" : basePackage;
        }
        String trimmed = suffix.trim();
        if (basePackage == null || basePackage.isBlank()) {
            return trimmed;
        }
        if (basePackage.endsWith("." + trimmed) || basePackage.equals(trimmed)) {
            return basePackage;
        }
        return basePackage + "." + trimmed;
    }

    private Path resolveTargetPath(String mainSourceRoot, String targetPackage, String className) {
        String packagePath = targetPackage.isEmpty() ? "" : targetPackage.replace('.', '/');
        return packagePath.isEmpty()
                ? Paths.get(mainSourceRoot, className + ".java")
                : Paths.get(mainSourceRoot, packagePath, className + ".java");
    }

    private String resolveTypeName(@Nullable TypeTree typeExpr) {
        if (typeExpr == null) {
            return "void";
        }
        if (typeExpr instanceof TypedTree) {
            TypedTree typed = (TypedTree) typeExpr;
            JavaType type = typed.getType();
            if (type != null) {
                return TypeUtils.toString(type).replace('$', '.');
            }
        }
        return typeExpr.printTrimmed();
    }

    private String resolveSimpleTypeName(@Nullable TypeTree typeExpr) {
        String fullName = resolveTypeName(typeExpr);
        if (fullName.startsWith("java.lang.")) {
            return fullName.substring("java.lang.".length());
        }
        int lastDot = fullName.lastIndexOf('.');
        if (lastDot > 0 && !fullName.contains("<")) {
            return fullName.substring(lastDot + 1);
        }
        return fullName;
    }

    private static String capitalize(String str) {
        if (str == null || str.isEmpty()) return str;
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }

    private static String decapitalize(String str) {
        if (str == null || str.isEmpty()) return str;
        return Character.toLowerCase(str.charAt(0)) + str.substring(1);
    }

    private static String extractMainSourceRoot(String sourcePath, ProjectConfiguration config) {
        if (sourcePath == null) {
            return "src/main/java";
        }
        String normalizedPath = sourcePath.replace('\\', '/');
        for (String root : config.getMainSourceRoots()) {
            String normalizedRoot = root.replace('\\', '/');
            String marker = "/" + normalizedRoot + "/";
            int markerIndex = normalizedPath.indexOf(marker);
            if (markerIndex >= 0) {
                return normalizedPath.substring(0, markerIndex + marker.length() - 1);
            }
            if (normalizedPath.startsWith(normalizedRoot + "/")) {
                return normalizedRoot;
            }
        }
        return "src/main/java";
    }

    private static Path extractProjectRoot(Path sourcePath) {
        if (sourcePath == null) {
            return Paths.get(System.getProperty("user.dir"));
        }
        Path current = sourcePath.toAbsolutePath().getParent();
        while (current != null) {
            if (Files.exists(current.resolve("pom.xml")) ||
                Files.exists(current.resolve("build.gradle")) ||
                Files.exists(current.resolve("build.gradle.kts")) ||
                Files.exists(current.resolve("settings.gradle")) ||
                Files.exists(current.resolve("settings.gradle.kts")) ||
                Files.exists(current.resolve("project.yaml"))) {
                return current;
            }
            current = current.getParent();
        }
        return sourcePath.toAbsolutePath().getParent();
    }
}
